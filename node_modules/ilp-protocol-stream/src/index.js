"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const events_1 = require("events");
const ILDCP = require("ilp-protocol-ildcp");
const IlpPacket = require("ilp-packet");
const Debug = require("debug");
const cryptoHelper = require("./crypto");
const crypto_1 = require("crypto");
const connection_1 = require("./connection");
const getPluginFromEnvironment = require('ilp-plugin');
require('source-map-support').install();
const CONNECTION_ID_REGEX = /^[a-zA-Z0-9_-]+$/;
function createConnection(opts) {
    return __awaiter(this, void 0, void 0, function* () {
        const plugin = opts.plugin || getPluginFromEnvironment();
        yield plugin.connect();
        const debug = Debug('ilp-protocol-stream:Client');
        const sourceAccount = (yield ILDCP.fetch(plugin.sendData.bind(plugin))).clientAddress;
        const connection = new connection_1.Connection(Object.assign({}, opts, { sourceAccount, isServer: false, plugin }));
        plugin.registerDataHandler((data) => __awaiter(this, void 0, void 0, function* () {
            let prepare;
            try {
                prepare = IlpPacket.deserializeIlpPrepare(data);
            }
            catch (err) {
                debug(`got data that is not an ILP Prepare packet: ${data.toString('hex')}`);
                return IlpPacket.serializeIlpReject({
                    code: 'F00',
                    message: `Expected an ILP Prepare packet (type 12), but got packet with type: ${data[0]}`,
                    data: Buffer.alloc(0),
                    triggeredBy: sourceAccount
                });
            }
            try {
                const fulfill = yield connection.handlePrepare(prepare);
                return IlpPacket.serializeIlpFulfill(fulfill);
            }
            catch (err) {
                if (!err.ilpErrorCode) {
                    debug('error handling prepare:', err);
                }
                return IlpPacket.serializeIlpReject({
                    code: err.ilpErrorCode || 'F00',
                    message: err.ilpErrorMessage || '',
                    data: err.ilpErrorData || Buffer.alloc(0),
                    triggeredBy: sourceAccount
                });
            }
        }));
        connection.once('close', () => {
            plugin.deregisterDataHandler();
            plugin.disconnect()
                .then(() => debug('plugin disconnected'))
                .catch((err) => debug('error disconnecting plugin:', err));
        });
        yield connection.connect();
        return connection;
    });
}
exports.createConnection = createConnection;
class Server extends events_1.EventEmitter {
    constructor(opts) {
        super();
        if (!opts) {
            opts = {};
        }
        this.serverSecret = opts.serverSecret || crypto_1.randomBytes(32);
        this.plugin = opts.plugin || getPluginFromEnvironment();
        this.debug = Debug('ilp-protocol-stream:Server');
        this.connections = {};
        this.connectionOpts = Object.assign({}, opts, {
            serverSecret: undefined
        });
        this.connected = false;
    }
    listen() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.connected && this.plugin.isConnected()) {
                return;
            }
            this.plugin.registerDataHandler(this.handleData.bind(this));
            yield this.plugin.connect();
            this.sourceAccount = (yield ILDCP.fetch(this.plugin.sendData.bind(this.plugin))).clientAddress;
            this.connected = true;
        });
    }
    acceptConnection() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.listen();
            return new Promise((resolve, reject) => {
                this.once('connection', resolve);
            });
        });
    }
    generateAddressAndSecret(connectionTag) {
        if (!this.connected) {
            throw new Error('Server must be connected to generate address and secret');
        }
        let token = base64url(cryptoHelper.generateToken());
        if (connectionTag) {
            if (!CONNECTION_ID_REGEX.test(connectionTag)) {
                throw new Error('connectionTag can only include ASCII characters a-z, A-Z, 0-9, "_", and "-"');
            }
            token = token + '~' + connectionTag;
        }
        const sharedSecret = cryptoHelper.generateSharedSecretFromToken(this.serverSecret, Buffer.from(token, 'ascii'));
        return {
            destinationAccount: `${this.sourceAccount}.${token}`,
            sharedSecret
        };
    }
    handleData(data) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                let prepare;
                try {
                    prepare = IlpPacket.deserializeIlpPrepare(data);
                }
                catch (err) {
                    this.debug(`got data that is not an ILP Prepare packet: ${data.toString('hex')}`);
                    return IlpPacket.serializeIlpReject({
                        code: 'F00',
                        message: `Expected an ILP Prepare packet (type 12), but got packet with type: ${data[0]}`,
                        data: Buffer.alloc(0),
                        triggeredBy: this.sourceAccount
                    });
                }
                const localAddressParts = prepare.destination.replace(this.sourceAccount + '.', '').split('.');
                if (localAddressParts.length === 0 || !localAddressParts[0]) {
                    this.debug(`destination in ILP Prepare packet does not have a Connection ID: ${prepare.destination}`);
                    throw new IlpPacket.Errors.UnreachableError('');
                }
                const connectionId = localAddressParts[0];
                if (!this.connections[connectionId]) {
                    let sharedSecret;
                    try {
                        const token = Buffer.from(connectionId, 'ascii');
                        sharedSecret = cryptoHelper.generateSharedSecretFromToken(this.serverSecret, token);
                        cryptoHelper.decrypt(sharedSecret, prepare.data);
                    }
                    catch (err) {
                        this.debug(`got prepare for an address and token that we did not generate: ${prepare.destination}`);
                        throw new IlpPacket.Errors.UnreachableError('');
                    }
                    const connectionTag = (connectionId.indexOf('~') !== -1 ? connectionId.slice(connectionId.indexOf('~') + 1) : undefined);
                    const connection = new connection_1.Connection(Object.assign({}, this.connectionOpts, { sourceAccount: this.sourceAccount, sharedSecret, isServer: true, connectionTag, plugin: this.plugin }));
                    this.connections[connectionId] = connection;
                    this.debug(`got incoming packet for new connection: ${connectionId}${(connectionTag ? ' (connectionTag: ' + connectionTag + ')' : '')}`);
                    try {
                        this.emit('connection', connection);
                    }
                    catch (err) {
                        this.debug('error in connection event handler:', err);
                    }
                    yield new Promise((resolve, reject) => setImmediate(resolve));
                }
                const fulfill = yield this.connections[connectionId].handlePrepare(prepare);
                return IlpPacket.serializeIlpFulfill(fulfill);
            }
            catch (err) {
                if (!err.ilpErrorCode) {
                    this.debug('error handling prepare:', err);
                }
                return IlpPacket.serializeIlpReject({
                    code: err.ilpErrorCode || 'F00',
                    message: err.ilpErrorMessage || '',
                    data: err.ilpErrorData || Buffer.alloc(0),
                    triggeredBy: this.sourceAccount || ''
                });
            }
        });
    }
}
exports.Server = Server;
function createServer(opts) {
    return __awaiter(this, void 0, void 0, function* () {
        const server = new Server(opts);
        yield server.listen();
        return server;
    });
}
exports.createServer = createServer;
function base64url(buffer) {
    return buffer.toString('base64')
        .replace(/=+$/, '')
        .replace(/\+/g, '-')
        .replace(/\//g, '_');
}
//# sourceMappingURL=index.js.map