"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const events_1 = require("events");
const Debug = require("debug");
const stream_1 = require("./stream");
const IlpPacket = require("ilp-packet");
const cryptoHelper = require("./crypto");
const packet_1 = require("./packet");
const oer_utils_1 = require("oer-utils");
const bignumber_js_1 = require("bignumber.js");
require('source-map-support').install();
const TEST_PACKET_AMOUNT = new bignumber_js_1.default(1000);
const RETRY_DELAY_START = 100;
const MAX_DATA_SIZE = 32767;
const DEFAULT_MAX_REMOTE_STREAMS = 10;
class ConnectionError extends Error {
    constructor(message, streamErrorCode) {
        super(message);
        this.streamErrorCode = streamErrorCode || packet_1.ErrorCode.InternalError;
    }
}
exports.ConnectionError = ConnectionError;
class Connection extends events_1.EventEmitter {
    constructor(opts) {
        super();
        this.plugin = opts.plugin;
        this.sourceAccount = opts.sourceAccount;
        this.destinationAccount = opts.destinationAccount;
        this.sharedSecret = opts.sharedSecret;
        this.isServer = opts.isServer;
        this.slippage = new bignumber_js_1.default(opts.slippage || 0);
        this.allowableReceiveExtra = new bignumber_js_1.default(1.01);
        this.enablePadding = !!opts.enablePadding;
        this.connectionTag = opts.connectionTag;
        this.maxStreamId = 2 * (opts.maxRemoteStreams || DEFAULT_MAX_REMOTE_STREAMS);
        this.maxBufferedData = opts.connectionBufferSize || MAX_DATA_SIZE * 2;
        this.nextPacketSequence = 1;
        this.streams = new Map();
        this.nextStreamId = (this.isServer ? 2 : 1);
        this.debug = Debug(`ilp-protocol-stream:${this.isServer ? 'Server' : 'Client'}:Connection`);
        this.sending = false;
        this.closed = true;
        this.queuedFrames = [];
        this.maximumPacketAmount = new bignumber_js_1.default(Infinity);
        this.testMaximumPacketAmount = new bignumber_js_1.default(Infinity);
        this.retryDelay = RETRY_DELAY_START;
        this.remoteClosed = false;
        this.remoteKnowsOurAccount = this.isServer;
        this.remoteMaxStreamId = DEFAULT_MAX_REMOTE_STREAMS;
        this.remoteMaxOffset = this.maxBufferedData;
        this._totalReceived = new bignumber_js_1.default(0);
        this._totalSent = new bignumber_js_1.default(0);
        this._totalDelivered = new bignumber_js_1.default(0);
        this._lastPacketExchangeRate = new bignumber_js_1.default(0);
    }
    connect() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.closed) {
                return Promise.resolve();
            }
            this.startSendLoop();
            yield new Promise((resolve, reject) => {
                const connectHandler = () => {
                    cleanup();
                    resolve();
                };
                const closeHandler = () => {
                    cleanup();
                    reject(new Error('Connection was closed before it was connected'));
                };
                const errorHandler = (error) => {
                    cleanup();
                    reject(new Error(`Error connecting${error ? ': ' + error.message : ''}`));
                };
                this.once('connect', connectHandler);
                this.once('error', errorHandler);
                this.once('close', closeHandler);
                this.once('end', closeHandler);
                const self = this;
                function cleanup() {
                    self.removeListener('connect', connectHandler);
                    self.removeListener('error', errorHandler);
                    self.removeListener('close', closeHandler);
                    self.removeListener('end', closeHandler);
                }
            });
            this.closed = false;
        });
    }
    end() {
        return __awaiter(this, void 0, void 0, function* () {
            this.debug('closing connection');
            this.closed = true;
            for (let [_, stream] of this.streams) {
                if (stream.isOpen()) {
                    stream.end();
                }
            }
            yield new Promise((resolve, reject) => {
                this.once('_send_loop_finished', resolve);
                this.once('error', reject);
                this.startSendLoop();
            });
            yield this.sendConnectionClose();
            this.safeEmit('end');
            this.safeEmit('close');
        });
    }
    destroy(err) {
        return __awaiter(this, void 0, void 0, function* () {
            this.debug('destroying connection with error:', err);
            if (err) {
                this.safeEmit('error', err);
            }
            for (let [_, stream] of this.streams) {
                stream.destroy();
            }
            yield this.sendConnectionClose(err);
            this.safeEmit('close');
        });
    }
    createStream() {
        if (this.remoteMaxStreamId < this.nextStreamId) {
            this.debug(`cannot creat another stream. nextStreamId: ${this.nextStreamId}, remote maxStreamId: ${this.remoteMaxStreamId}`);
            this.queuedFrames.push(new packet_1.ConnectionStreamIdBlockedFrame(this.nextStreamId));
            throw new Error(`Creating another stream would exceed the remote connection's maximum number of open streams`);
        }
        const stream = new stream_1.DataAndMoneyStream({
            id: this.nextStreamId,
            isServer: this.isServer
        });
        this.streams.set(this.nextStreamId, stream);
        this.debug(`created stream: ${this.nextStreamId}`);
        this.nextStreamId += 2;
        stream.on('_maybe_start_send_loop', this.startSendLoop.bind(this));
        return stream;
    }
    get minimumAcceptableExchangeRate() {
        if (this.exchangeRate) {
            const minimumExchangeWithSlippage = this.exchangeRate
                .times(new bignumber_js_1.default(1).minus(this.slippage));
            return minimumExchangeWithSlippage.toString();
        }
        return '0';
    }
    get lastPacketExchangeRate() {
        return this._lastPacketExchangeRate.toString();
    }
    get totalDelivered() {
        return this._totalDelivered.toString();
    }
    get totalSent() {
        return this._totalSent.toString();
    }
    get totalReceived() {
        return this._totalReceived.toString();
    }
    handlePrepare(prepare) {
        return __awaiter(this, void 0, void 0, function* () {
            let requestPacket;
            try {
                requestPacket = packet_1.Packet.decryptAndDeserialize(this.sharedSecret, prepare.data);
            }
            catch (err) {
                this.debug(`error parsing frames:`, err);
                throw new IlpPacket.Errors.UnexpectedPaymentError('');
            }
            this.debug('handling packet:', JSON.stringify(requestPacket));
            if (requestPacket.ilpPacketType.valueOf() !== IlpPacket.Type.TYPE_ILP_PREPARE) {
                this.debug(`prepare packet contains a frame that says it should be something other than a prepare: ${requestPacket.ilpPacketType}`);
                throw new IlpPacket.Errors.UnexpectedPaymentError('');
            }
            let responseFrames = [];
            responseFrames.push(new packet_1.ConnectionMaxDataFrame(this.getIncomingOffsets().maxAcceptable));
            const throwFinalApplicationError = () => {
                responseFrames = responseFrames.concat(this.queuedFrames);
                this.queuedFrames = [];
                const responsePacket = new packet_1.Packet(requestPacket.sequence, packet_1.IlpPacketType.Reject, prepare.amount, responseFrames);
                this.debug(`rejecting packet ${requestPacket.sequence}: ${JSON.stringify(responsePacket)}`);
                throw new IlpPacket.Errors.FinalApplicationError('', responsePacket.serializeAndEncrypt(this.sharedSecret, (this.enablePadding ? MAX_DATA_SIZE : undefined)));
            };
            try {
                this.handleFrames(requestPacket.frames);
            }
            catch (err) {
                this.debug('error handling frames:', err);
                throwFinalApplicationError();
            }
            const incomingOffsets = this.getIncomingOffsets();
            if (incomingOffsets.max > incomingOffsets.maxAcceptable) {
                this.destroy(new ConnectionError(`Exceeded flow control limits. Max connection byte offset: ${incomingOffsets.maxAcceptable}, received: ${incomingOffsets.max}`, packet_1.ErrorCode.FlowControlError));
                throwFinalApplicationError();
            }
            if (requestPacket.prepareAmount.isGreaterThan(prepare.amount)) {
                this.debug(`received less than minimum destination amount. actual: ${prepare.amount}, expected: ${requestPacket.prepareAmount}`);
                throwFinalApplicationError();
            }
            const fulfillment = cryptoHelper.generateFulfillment(this.sharedSecret, prepare.data);
            const generatedCondition = cryptoHelper.hash(fulfillment);
            if (!generatedCondition.equals(prepare.executionCondition)) {
                this.debug(`got unfulfillable prepare for amount: ${prepare.amount}. generated condition: ${generatedCondition.toString('hex')}, prepare condition: ${prepare.executionCondition.toString('hex')}`);
                throwFinalApplicationError();
            }
            const amountsToReceive = [];
            const totalMoneyShares = requestPacket.frames.reduce((sum, frame) => {
                if (frame instanceof packet_1.StreamMoneyFrame) {
                    return sum.plus(frame.shares);
                }
                return sum;
            }, new bignumber_js_1.default(0));
            for (let frame of requestPacket.frames) {
                if (!(frame instanceof packet_1.StreamMoneyFrame)) {
                    continue;
                }
                const streamId = frame.streamId.toNumber();
                const streamAmount = new bignumber_js_1.default(prepare.amount)
                    .times(frame.shares)
                    .dividedBy(totalMoneyShares)
                    .integerValue(bignumber_js_1.default.ROUND_FLOOR);
                const stream = this.streams.get(streamId);
                amountsToReceive.push({
                    stream,
                    amount: streamAmount
                });
                const maxStreamCanReceive = stream._getAmountStreamCanReceive()
                    .times(this.allowableReceiveExtra)
                    .integerValue(bignumber_js_1.default.ROUND_CEIL);
                if (maxStreamCanReceive.isLessThan(streamAmount)) {
                    this.debug(`peer sent too much for stream: ${streamId}. got: ${streamAmount}, max receivable: ${maxStreamCanReceive}`);
                    responseFrames.push(new packet_1.StreamMaxMoneyFrame(streamId, stream.receiveMax, stream.totalReceived));
                    throwFinalApplicationError();
                }
                if (!stream.isOpen()) {
                    this.debug(`peer sent money for stream that was already closed: ${streamId}`);
                    responseFrames.push(new packet_1.StreamCloseFrame(streamId, packet_1.ErrorCode.StreamStateError, 'Stream is already closed'));
                    throwFinalApplicationError();
                }
            }
            for (let { stream, amount } of amountsToReceive) {
                stream._addToIncoming(amount);
            }
            if (!this.closed && !this.remoteClosed) {
                for (let [_, stream] of this.streams) {
                    const streamIsClosed = !stream.isOpen() && stream._getAmountAvailableToSend().isEqualTo(0);
                    if (streamIsClosed && !stream._remoteClosed) {
                        this.debug(`telling other side that stream ${stream.id} is closed`);
                        if (stream._errorMessage) {
                            responseFrames.push(new packet_1.StreamCloseFrame(stream.id, packet_1.ErrorCode.ApplicationError, stream._errorMessage));
                        }
                        else {
                            responseFrames.push(new packet_1.StreamCloseFrame(stream.id, packet_1.ErrorCode.NoError, ''));
                        }
                        stream._remoteClosed = true;
                    }
                    else {
                        this.debug(`telling other side that stream ${stream.id} can receive ${stream.receiveMax}`);
                        responseFrames.push(new packet_1.StreamMaxMoneyFrame(stream.id, stream.receiveMax, stream.totalReceived));
                        responseFrames.push(new packet_1.StreamMaxDataFrame(stream.id, stream._getIncomingOffsets().maxAcceptable));
                    }
                }
            }
            responseFrames = responseFrames.concat(this.queuedFrames);
            this.queuedFrames = [];
            const responsePacket = new packet_1.Packet(requestPacket.sequence, packet_1.IlpPacketType.Fulfill, prepare.amount, responseFrames);
            this._totalReceived = this._totalReceived.plus(prepare.amount);
            this.debug(`fulfilling prepare with fulfillment: ${fulfillment.toString('hex')} and response packet: ${JSON.stringify(responsePacket)}`);
            return {
                fulfillment,
                data: responsePacket.serializeAndEncrypt(this.sharedSecret, (this.enablePadding ? MAX_DATA_SIZE : undefined))
            };
        });
    }
    handleFrames(frames) {
        for (let frame of frames) {
            let stream;
            switch (frame.type) {
                case packet_1.FrameType.ConnectionNewAddress:
                    this.debug(`peer notified us of their account: ${frame.sourceAccount}`);
                    const firstConnection = this.destinationAccount === undefined;
                    this.destinationAccount = frame.sourceAccount;
                    if (firstConnection) {
                        this.handleConnect();
                    }
                    break;
                case packet_1.FrameType.ConnectionClose:
                    this.sending = false;
                    this.closed = true;
                    this.remoteClosed = true;
                    if (frame.errorCode === packet_1.ErrorCode.NoError) {
                        this.debug(`remote closed connection`);
                        this.end();
                    }
                    else {
                        this.debug(`remote connection error. code: ${packet_1.ErrorCode[frame.errorCode]}, message: ${frame.errorMessage}`);
                        this.destroy(new Error(`Remote connection error. Code: ${packet_1.ErrorCode[frame.errorCode]}, message: ${frame.errorMessage}`));
                    }
                    break;
                case packet_1.FrameType.ConnectionMaxData:
                    const outgoingOffsets = this.getOutgoingOffsets();
                    this.debug(`remote connection max byte offset is: ${frame.maxOffset}, we've sent: ${outgoingOffsets.currentOffset}, we want to send up to: ${outgoingOffsets.maxOffset}`);
                    if (frame.maxOffset.isGreaterThan(MAX_DATA_SIZE * 2)) {
                        this.remoteMaxOffset = Math.max(frame.maxOffset.toNumber(), this.remoteMaxOffset);
                    }
                    else {
                        this.remoteMaxOffset = frame.maxOffset.toNumber();
                    }
                    break;
                case packet_1.FrameType.ConnectionDataBlocked:
                    this.debug(`remote wants to send more data but we are blocking them. current max incoming offset: ${this.getIncomingOffsets()}, remote max offset: ${frame.maxOffset}`);
                    break;
                case packet_1.FrameType.ConnectionMaxStreamId:
                    this.debug(`remote set max stream id to ${frame.maxStreamId}`);
                    this.remoteMaxStreamId = frame.maxStreamId.toNumber();
                    break;
                case packet_1.FrameType.ConnectionStreamIdBlocked:
                    this.debug(`remote wants to open more streams but we are blocking them`);
                    break;
                case packet_1.FrameType.StreamClose:
                    this.handleNewStream(frame.streamId.toNumber());
                    this.handleStreamClose(frame);
                    break;
                case packet_1.FrameType.StreamMoney:
                    this.handleNewStream(frame.streamId.toNumber());
                    break;
                case packet_1.FrameType.StreamMaxMoney:
                    this.handleNewStream(frame.streamId.toNumber());
                    this.debug(`peer told us that stream ${frame.streamId} can receive up to: ${frame.receiveMax} and has received: ${frame.totalReceived} so far`);
                    stream = this.streams.get(frame.streamId.toNumber());
                    stream._remoteReceived = bignumber_js_1.default.maximum(stream._remoteReceived, frame.totalReceived);
                    if (stream._remoteReceiveMax.isFinite()) {
                        stream._remoteReceiveMax = bignumber_js_1.default.maximum(stream._remoteReceiveMax, frame.receiveMax);
                    }
                    else {
                        stream._remoteReceiveMax = frame.receiveMax;
                    }
                    if (stream._remoteReceiveMax.isGreaterThan(stream._remoteReceived)
                        && stream._getAmountAvailableToSend().isGreaterThan(0)) {
                        this.startSendLoop();
                    }
                    break;
                case packet_1.FrameType.StreamMoneyBlocked:
                    this.handleNewStream(frame.streamId.toNumber());
                    this.debug(`peer told us that they want to send more money on stream ${frame.streamId} but we are blocking them. they have sent: ${frame.totalSent} so far and want to send: ${frame.sendMax}`);
                    break;
                case packet_1.FrameType.StreamData:
                    this.handleNewStream(frame.streamId.toNumber());
                    this.debug(`got data for stream ${frame.streamId}`);
                    stream = this.streams.get(frame.streamId.toNumber());
                    stream._pushIncomingData(frame.data, frame.offset.toNumber());
                    const incomingOffsets = stream._getIncomingOffsets();
                    if (incomingOffsets.max > incomingOffsets.maxAcceptable) {
                        this.destroy(new ConnectionError(`Exceeded flow control limits. Stream ${stream.id} can accept up to offset: ${incomingOffsets.maxAcceptable} but got bytes up to offset: ${incomingOffsets.max}`));
                    }
                    break;
                case packet_1.FrameType.StreamMaxData:
                    this.handleNewStream(frame.streamId.toNumber());
                    stream = this.streams.get(frame.streamId.toNumber());
                    this.debug(`peer told us that stream ${frame.streamId} can receive up to byte offset: ${frame.maxOffset} (we've sent up to offset: ${stream._getOutgoingOffsets().current})`);
                    const oldOffset = stream._remoteMaxOffset;
                    stream._remoteMaxOffset = frame.maxOffset.toNumber();
                    if (stream._remoteMaxOffset > oldOffset) {
                        this.startSendLoop();
                    }
                    break;
                case packet_1.FrameType.StreamDataBlocked:
                    this.handleNewStream(frame.streamId.toNumber());
                    stream = this.streams.get(frame.streamId.toNumber());
                    this.debug(`peer told us that stream ${frame.streamId} is blocked. they want to send up to offset: ${frame.maxOffset}, but we are only allowing up to: ${stream._getIncomingOffsets().maxAcceptable}`);
                    break;
                default:
                    continue;
            }
        }
    }
    handleConnect() {
        this.closed = false;
        this.debug('connected');
        this.safeEmit('connect');
        this.queuedFrames.push(new packet_1.ConnectionMaxStreamIdFrame(this.maxStreamId));
    }
    handleNewStream(streamId) {
        if (this.streams.has(streamId)) {
            return;
        }
        if (this.isServer && streamId % 2 === 0) {
            this.debug(`got invalid stream ID ${streamId} from peer (should be odd)`);
            this.queuedFrames.push(new packet_1.ConnectionCloseFrame(packet_1.ErrorCode.ProtocolViolation, `Invalid Stream ID: ${streamId}. Client-initiated streams must have odd-numbered IDs`));
            const err = new Error(`Invalid Stream ID: ${streamId}. Client-initiated streams must have odd-numbered IDs`);
            this.safeEmit('error', err);
            throw err;
        }
        else if (!this.isServer && streamId % 2 === 1) {
            this.debug(`got invalid stream ID ${streamId} from peer (should be even)`);
            this.queuedFrames.push(new packet_1.ConnectionCloseFrame(packet_1.ErrorCode.ProtocolViolation, `Invalid Stream ID: ${streamId}. Server-initiated streams must have even-numbered IDs`));
            const err = new Error(`Invalid Stream ID: ${streamId}. Server-initiated streams must have even-numbered IDs`);
            this.safeEmit('error', err);
            throw err;
        }
        if (streamId > this.maxStreamId) {
            this.debug(`peer opened too many streams. got stream: ${streamId}, but max stream id is: ${this.maxStreamId}. closing connection`);
            this.queuedFrames.push(new packet_1.ConnectionCloseFrame(packet_1.ErrorCode.StreamIdError, `Maximum number of open streams exceeded. Got stream: ${streamId}, current max stream ID: ${this.maxStreamId}`));
            const err = new Error(`Maximum number of open streams exceeded. Got stream: ${streamId}, current max stream ID: ${this.maxStreamId}`);
            this.safeEmit('error', err);
            throw err;
        }
        if (this.maxStreamId * .75 < streamId) {
            this.debug(`informing peer that our max stream id is: ${this.maxStreamId}`);
            this.queuedFrames.push(new packet_1.ConnectionMaxStreamIdFrame(this.maxStreamId));
        }
        this.debug(`got new stream: ${streamId}`);
        const stream = new stream_1.DataAndMoneyStream({
            id: streamId,
            isServer: this.isServer
        });
        this.streams.set(streamId, stream);
        stream.on('_maybe_start_send_loop', () => this.startSendLoop());
        this.safeEmit('stream', stream);
    }
    handleStreamClose(frame) {
        const streamId = frame.streamId.toNumber();
        const stream = this.streams.get(streamId);
        if (!stream) {
            this.debug(`remote error on stream ${streamId}, but we don't have a record of that stream`);
            return;
        }
        if (!stream.isOpen() || stream._remoteSentEnd) {
            return;
        }
        this.debug(`peer closed stream ${stream.id} with error code: ${packet_1.ErrorCode[frame.errorCode]} and message: ${frame.errorMessage}`);
        stream._sentEnd = true;
        let err;
        if (frame.errorMessage) {
            err = new Error(frame.errorMessage);
            err.name = packet_1.ErrorCode[frame.errorCode];
        }
        stream._remoteEnded(err);
        this.maxStreamId += 2;
        this.debug(`raising maxStreamId to ${this.maxStreamId}`);
        this.queuedFrames.push(new packet_1.ConnectionMaxStreamIdFrame(this.maxStreamId));
    }
    startSendLoop() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.sending) {
                return;
            }
            if (this.remoteClosed) {
                this.debug('remote connection is already closed, not starting another loop');
                this.safeEmit('_send_loop_finished');
                return;
            }
            if (!this.destinationAccount) {
                this.debug('not sending because we do not know the client\'s address');
                this.sending = false;
                return;
            }
            this.sending = true;
            this.debug('starting send loop');
            try {
                while (this.sending) {
                    if (!this.exchangeRate) {
                        this.debug('determining exchange rate');
                        yield this.sendTestPacket();
                        if (this.exchangeRate) {
                            this.safeEmit('connect');
                            this.debug('connected');
                        }
                    }
                    else {
                        yield this.loadAndSendPacket();
                    }
                }
            }
            catch (err) {
                return this.destroy(err);
            }
            this.debug('finished sending');
            this.safeEmit('_send_loop_finished');
            for (let [_, stream] of this.streams) {
                stream.emit('_send_loop_finished');
            }
        });
    }
    loadAndSendPacket() {
        return __awaiter(this, void 0, void 0, function* () {
            yield new Promise((resolve, reject) => setImmediate(resolve));
            this.debug('loadAndSendPacket');
            let amountToSend = new bignumber_js_1.default(0);
            const requestPacket = new packet_1.Packet(this.nextPacketSequence++, packet_1.IlpPacketType.Prepare);
            requestPacket.frames = this.queuedFrames;
            this.queuedFrames = [];
            for (let [_, stream] of this.streams) {
                if (stream && stream.isOpen()) {
                    requestPacket.frames.push(new packet_1.StreamMaxMoneyFrame(stream.id, stream.receiveMax, stream.totalReceived));
                }
            }
            if (this.closed && !this.remoteClosed) {
                this.debug('sending connection close frame');
                requestPacket.frames.push(new packet_1.ConnectionCloseFrame(packet_1.ErrorCode.NoError, ''));
                this.remoteClosed = true;
            }
            let maxAmountFromNextStream = this.testMaximumPacketAmount;
            const streamsSentFrom = [];
            for (let [_, stream] of this.streams) {
                if (stream._sentEnd) {
                    continue;
                }
                let amountToSendFromStream = bignumber_js_1.default.minimum(stream._getAmountAvailableToSend(), maxAmountFromNextStream);
                if (this.exchangeRate) {
                    const maxDestinationAmount = stream._remoteReceiveMax.minus(stream._remoteReceived);
                    const maxSourceAmount = maxDestinationAmount.dividedBy(this.exchangeRate).integerValue(bignumber_js_1.default.ROUND_CEIL);
                    if (maxSourceAmount.isLessThan(amountToSendFromStream)) {
                        this.debug(`stream ${stream.id} could send ${amountToSendFromStream} but that would be more than the receiver says they can receive, so we'll send ${maxSourceAmount} instead`);
                        amountToSendFromStream = maxSourceAmount;
                    }
                }
                this.debug(`amount to send from stream ${stream.id}: ${amountToSendFromStream}, exchange rate: ${this.exchangeRate}, remote total received: ${stream._remoteReceived}, remote receive max: ${stream._remoteReceiveMax}`);
                if (amountToSendFromStream.isGreaterThan(0)) {
                    stream._holdOutgoing(requestPacket.sequence.toString(), amountToSendFromStream);
                    requestPacket.frames.push(new packet_1.StreamMoneyFrame(stream.id, amountToSendFromStream));
                    amountToSend = amountToSend.plus(amountToSendFromStream);
                    maxAmountFromNextStream = maxAmountFromNextStream.minus(amountToSendFromStream);
                    streamsSentFrom.push(stream);
                }
                const amountLeftStreamWantsToSend = new bignumber_js_1.default(stream.sendMax).minus(stream.totalSent).minus(amountToSendFromStream);
                if (amountLeftStreamWantsToSend.times(this.exchangeRate).isGreaterThan(stream._remoteReceiveMax.minus(stream._remoteReceived))) {
                    requestPacket.frames.push(new packet_1.StreamMoneyBlockedFrame(stream.id, stream.sendMax, stream.totalSent));
                }
                if (maxAmountFromNextStream.isEqualTo(0)) {
                    break;
                }
            }
            let sendingData = false;
            let bytesLeftInPacket = MAX_DATA_SIZE - requestPacket.byteLength();
            const maxBytesRemoteConnectionCanReceive = this.remoteMaxOffset - this.getOutgoingOffsets().currentOffset;
            if (bytesLeftInPacket > maxBytesRemoteConnectionCanReceive) {
                const outgoingMaxOffset = this.getOutgoingOffsets().maxOffset;
                this.debug(`peer is blocking us from sending more data. they will only accept up to offset: ${this.remoteMaxOffset}, but we want to send up to: ${outgoingMaxOffset}`);
                requestPacket.frames.push(new packet_1.ConnectionDataBlockedFrame(outgoingMaxOffset));
                bytesLeftInPacket = maxBytesRemoteConnectionCanReceive;
            }
            for (let [_, stream] of this.streams) {
                const { data, offset } = stream._getAvailableDataToSend(bytesLeftInPacket - 20);
                if (data && data.length > 0) {
                    const streamDataFrame = new packet_1.StreamDataFrame(stream.id, offset, data);
                    this.debug(`sending ${data.length} bytes from stream ${stream.id}`);
                    bytesLeftInPacket -= streamDataFrame.byteLength();
                    requestPacket.frames.push(streamDataFrame);
                    sendingData = true;
                }
                const maxOutgoingOffset = stream._isDataBlocked();
                if (maxOutgoingOffset) {
                    this.debug(`telling remote that stream ${stream.id} is blocked and has more data to send`);
                    requestPacket.frames.push(new packet_1.StreamDataBlockedFrame(stream.id, maxOutgoingOffset));
                }
            }
            if (amountToSend.isEqualTo(0) && !sendingData) {
                this.debug(`packet value is 0 and there is no data to send so we'll send this packet and then stop`);
                this.sending = false;
            }
            if (!this.closed) {
                for (let [_, stream] of this.streams) {
                    if (stream.isOpen() || stream._sentEnd) {
                        continue;
                    }
                    if (stream._getAmountAvailableToSend().isGreaterThan(0)) {
                        this.debug(`stream ${stream.id} is closed but still has money to send, not sending end frame yet`);
                        continue;
                    }
                    if (stream._hasDataToSend()) {
                        this.debug(`stream ${stream.id} is closed but still has data to send, not sending end frame yet`);
                        continue;
                    }
                    const streamEndFrame = (stream._errorMessage
                        ? new packet_1.StreamCloseFrame(stream.id, packet_1.ErrorCode.ApplicationError, stream._errorMessage)
                        : new packet_1.StreamCloseFrame(stream.id, packet_1.ErrorCode.NoError, ''));
                    if (streamEndFrame.byteLength() > bytesLeftInPacket) {
                        this.debug('not sending more stream end frames because the packet is full');
                        break;
                    }
                    this.debug(`sending end frame for stream ${stream.id}`);
                    requestPacket.frames.push(streamEndFrame);
                    bytesLeftInPacket -= streamEndFrame.byteLength();
                    stream._sentEnd = true;
                }
            }
            if (this.exchangeRate) {
                const minimumDestinationAmount = amountToSend.times(this.exchangeRate)
                    .times(new bignumber_js_1.default(1).minus(this.slippage))
                    .integerValue(bignumber_js_1.default.ROUND_FLOOR);
                if (minimumDestinationAmount.isGreaterThan(0)) {
                    requestPacket.prepareAmount = minimumDestinationAmount;
                }
            }
            if (amountToSend.isEqualTo(0) && requestPacket.frames.length === 0) {
                this.debug(`no money or data needs to be send, stopping loop`);
                this.sending = false;
                return;
            }
            const responsePacket = yield this.sendPacket(requestPacket, amountToSend, false);
            if (responsePacket) {
                this.handleFrames(responsePacket.frames);
                if (amountToSend.isGreaterThan(0)) {
                    this._lastPacketExchangeRate = responsePacket.prepareAmount.dividedBy(amountToSend);
                }
                if (responsePacket.ilpPacketType === packet_1.IlpPacketType.Fulfill) {
                    for (let stream of streamsSentFrom) {
                        stream._executeHold(requestPacket.sequence.toString());
                    }
                    this._totalDelivered = this._totalDelivered.plus(responsePacket.prepareAmount);
                    this._totalSent = this._totalSent.plus(amountToSend);
                    if (this.maximumPacketAmount.isFinite()
                        && amountToSend.isEqualTo(this.testMaximumPacketAmount)
                        && this.testMaximumPacketAmount.isLessThan(this.maximumPacketAmount)) {
                        const newTestMax = this.maximumPacketAmount.plus(this.testMaximumPacketAmount).dividedToIntegerBy(2);
                        this.debug(`maximum packet amount is between ${this.testMaximumPacketAmount} and ${this.maximumPacketAmount}, trying: ${newTestMax}`);
                        this.testMaximumPacketAmount = newTestMax;
                    }
                    this.retryDelay = RETRY_DELAY_START;
                }
            }
        });
    }
    sendTestPacket(amount) {
        return __awaiter(this, void 0, void 0, function* () {
            this.debug('sendTestPacket');
            if (!this.destinationAccount) {
                throw new Error('Cannot send test packet. Destination account is unknown');
            }
            const requestPacket = new packet_1.Packet(this.nextPacketSequence++, packet_1.IlpPacketType.Prepare);
            if (!this.remoteKnowsOurAccount) {
                this.debug('sending source address to peer');
                requestPacket.frames.push(new packet_1.ConnectionNewAddressFrame(this.sourceAccount));
            }
            const sourceAmount = amount || bignumber_js_1.default.minimum(TEST_PACKET_AMOUNT, this.testMaximumPacketAmount);
            const responsePacket = yield this.sendPacket(requestPacket, sourceAmount, true);
            if (!responsePacket) {
                return;
            }
            this.remoteKnowsOurAccount = true;
            this.exchangeRate = responsePacket.prepareAmount.dividedBy(sourceAmount);
            this.debug(`determined exchange rate to be: ${this.exchangeRate}`);
            if (this.exchangeRate.isEqualTo(0)) {
                throw new Error('Exchange rate is 0. We will not be able to send anything through this path');
            }
            this.handleFrames(responsePacket.frames);
        });
    }
    sendConnectionClose(err) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.remoteClosed) {
                this.debug('not sending connection error because remote is already closed');
                return;
            }
            let errorCode;
            let errorMessage;
            if (err && err instanceof ConnectionError) {
                errorCode = err.streamErrorCode;
                errorMessage = err.message;
            }
            else if (err) {
                errorCode = packet_1.ErrorCode.InternalError;
                errorMessage = err.message;
            }
            else {
                errorCode = packet_1.ErrorCode.NoError;
                errorMessage = '';
            }
            const packet = new packet_1.Packet(this.nextPacketSequence, packet_1.IlpPacketType.Prepare, 0, [
                new packet_1.ConnectionCloseFrame(errorCode, errorMessage)
            ]);
            try {
                yield this.sendPacket(packet, new bignumber_js_1.default(0), true);
            }
            catch (err) {
                this.debug(`error while trying to inform peer that connection is closing, but closing anyway`, err);
            }
            this.remoteClosed = true;
        });
    }
    sendPacket(packet, sourceAmount, unfulfillable = false) {
        return __awaiter(this, void 0, void 0, function* () {
            this.debug(`sending packet ${packet.sequence} with source amount: ${sourceAmount}: ${JSON.stringify(packet)})`);
            const data = packet.serializeAndEncrypt(this.sharedSecret, (this.enablePadding ? MAX_DATA_SIZE : undefined));
            let fulfillment;
            let executionCondition;
            if (unfulfillable) {
                fulfillment = undefined;
                executionCondition = cryptoHelper.generateRandomCondition();
            }
            else {
                fulfillment = cryptoHelper.generateFulfillment(this.sharedSecret, data);
                executionCondition = cryptoHelper.hash(fulfillment);
            }
            const prepare = {
                destination: this.destinationAccount,
                amount: (sourceAmount).toString(),
                data,
                executionCondition,
                expiresAt: new Date(Date.now() + 30000)
            };
            const responseData = yield this.plugin.sendData(IlpPacket.serializeIlpPrepare(prepare));
            let response;
            try {
                if (responseData[0] === IlpPacket.Type.TYPE_ILP_FULFILL) {
                    response = IlpPacket.deserializeIlpFulfill(responseData);
                }
                else if (responseData[0] === IlpPacket.Type.TYPE_ILP_REJECT) {
                    response = IlpPacket.deserializeIlpReject(responseData);
                }
                else {
                    throw new Error(`Invalid response packet type: ${responseData[0]}`);
                }
            }
            catch (err) {
                this.debug(`got invalid response from sending packet ${packet.sequence}:`, err, responseData.toString('hex'));
                throw new Error(`Invalid response when sending packet ${packet.sequence}: ${err.message}`);
            }
            if (fulfillment && isFulfill(response)) {
                if (!cryptoHelper.hash(response.fulfillment).equals(executionCondition)) {
                    this.debug(`got invalid fulfillment for packet ${packet.sequence}: ${response.fulfillment.toString('hex')}. expected: ${fulfillment.toString('hex')} for condition: ${executionCondition.toString('hex')}`);
                    throw new Error(`Got invalid fulfillment for packet ${packet.sequence}. Actual: ${response.fulfillment.toString('hex')}, expected: ${fulfillment.toString('hex')}`);
                }
            }
            else {
                response = response;
                this.undoRejectedPacket(packet);
                if (response.code !== 'F99') {
                    return this.handleConnectorError(response, sourceAmount);
                }
            }
            if (response.data.length === 0) {
                return undefined;
            }
            let responsePacket;
            try {
                responsePacket = packet_1.Packet.decryptAndDeserialize(this.sharedSecret, response.data);
            }
            catch (err) {
                this.debug(`unable to decrypt and parse response data:`, err, response.data.toString('hex'));
                throw new Error('Unable to decrypt and parse response data: ' + err.message);
            }
            if (!responsePacket.sequence.isEqualTo(packet.sequence)) {
                this.debug(`response packet sequence does not match the request packet. expected sequence: ${packet.sequence}, got response packet:`, JSON.stringify(responsePacket));
                throw new Error(`Response packet sequence does not correspond to the request. Actual: ${responsePacket.sequence}, expected: ${packet.sequence}`);
            }
            if (responsePacket.ilpPacketType !== responseData[0]) {
                this.debug(`response packet was on wrong ILP packet type. expected ILP packet type: ${responseData[0]}, got:`, JSON.stringify(responsePacket));
                throw new Error(`Response says it should be on an ILP packet of type: ${responsePacket.ilpPacketType} but it was carried on an ILP packet of type: ${responseData[0]}`);
            }
            this.debug(`got response to packet: ${packet.sequence}: ${JSON.stringify(responsePacket)}`);
            return responsePacket;
        });
    }
    undoRejectedPacket(requestPacket) {
        this.debug(`packet ${requestPacket.sequence} was rejected`);
        for (let frame of requestPacket.frames) {
            switch (frame.type) {
                case packet_1.FrameType.StreamMoney:
                    this.streams.get(frame.streamId.toNumber())._cancelHold(requestPacket.sequence.toString());
                    break;
                case packet_1.FrameType.StreamData:
                    this.streams.get(frame.streamId.toNumber())._resendOutgoingData(frame.data, frame.offset.toNumber());
                    break;
                default:
                    continue;
            }
        }
    }
    handleConnectorError(reject, amountSent) {
        return __awaiter(this, void 0, void 0, function* () {
            this.debug(`handling reject:`, JSON.stringify(reject));
            if (reject.code === 'F08') {
                let receivedAmount;
                let maximumAmount;
                try {
                    const reader = oer_utils_1.Reader.from(reject.data);
                    receivedAmount = reader.readUInt64BigNum();
                    maximumAmount = reader.readUInt64BigNum();
                }
                catch (err) {
                    receivedAmount = undefined;
                    maximumAmount = undefined;
                }
                if (receivedAmount && maximumAmount && receivedAmount.isGreaterThan(maximumAmount)) {
                    const newMaximum = amountSent
                        .times(maximumAmount)
                        .dividedToIntegerBy(receivedAmount);
                    this.debug(`reducing maximum packet amount from ${this.maximumPacketAmount} to ${newMaximum}`);
                    this.maximumPacketAmount = newMaximum;
                    this.testMaximumPacketAmount = newMaximum;
                }
                else {
                    this.maximumPacketAmount = amountSent.minus(1);
                    this.testMaximumPacketAmount = this.maximumPacketAmount.dividedToIntegerBy(2);
                }
                if (this.maximumPacketAmount.isEqualTo(0)) {
                    this.debug(`cannot send anything through this path. the maximum packet amount is 0`);
                    throw new Error('Cannot send. Path has a Maximum Packet Amount of 0');
                }
            }
            else if (reject.code[0] === 'T') {
                this.debug(`got temporary error. waiting ${this.retryDelay} before trying again`);
                const delay = this.retryDelay;
                this.retryDelay = this.retryDelay * 2;
                yield new Promise((resolve, reject) => setTimeout(resolve, delay));
            }
            else {
                this.debug(`unexpected error. code: ${reject.code}, message: ${reject.message}, data: ${reject.data.toString('hex')}`);
                throw new Error(`Unexpected error while sending packet. Code: ${reject.code}, message: ${reject.message}`);
            }
        });
    }
    safeEmit(event, ...args) {
        try {
            args.unshift(event);
            this.emit.apply(this, args);
        }
        catch (err) {
            this.debug(`error in ${event} handler:`, err);
        }
    }
    getOutgoingOffsets() {
        let currentOffset = 0;
        let maxOffset = 0;
        for (let [_, stream] of this.streams) {
            const streamOffsets = stream._getOutgoingOffsets();
            currentOffset += streamOffsets.current;
            maxOffset += streamOffsets.max;
        }
        return {
            currentOffset,
            maxOffset
        };
    }
    getIncomingOffsets() {
        let totalMaxOffset = 0;
        let totalReadOffset = 0;
        let totalBufferedData = 0;
        for (let [_, stream] of this.streams) {
            const { max, current } = stream._getIncomingOffsets();
            totalMaxOffset += max;
            totalReadOffset += current;
            totalBufferedData += stream.readableLength;
        }
        return {
            current: totalReadOffset,
            max: totalMaxOffset,
            maxAcceptable: totalReadOffset - totalBufferedData + this.maxBufferedData
        };
    }
}
exports.Connection = Connection;
function isFulfill(packet) {
    return packet.hasOwnProperty('fulfillment');
}
//# sourceMappingURL=connection.js.map