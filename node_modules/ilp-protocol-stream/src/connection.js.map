{"version":3,"file":"connection.js","sourceRoot":"","sources":["connection.ts"],"names":[],"mappings":"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","sourcesContent":["import { EventEmitter } from 'events'\nimport * as Debug from 'debug'\nimport { DataAndMoneyStream } from './stream'\nimport * as IlpPacket from 'ilp-packet'\nimport * as cryptoHelper from './crypto'\nimport {\n  Packet,\n  Frame,\n  StreamMoneyFrame,\n  StreamCloseFrame,\n  StreamDataFrame,\n  StreamMaxMoneyFrame,\n  FrameType,\n  IlpPacketType,\n  ConnectionNewAddressFrame,\n  ErrorCode,\n  ConnectionCloseFrame,\n  ConnectionStreamIdBlockedFrame,\n  ConnectionMaxStreamIdFrame,\n  StreamMaxDataFrame,\n  StreamDataBlockedFrame,\n  ConnectionMaxDataFrame,\n  ConnectionDataBlockedFrame,\n  StreamMoneyBlockedFrame\n} from './packet'\nimport { Reader } from 'oer-utils'\nimport { Plugin } from './util/plugin-interface'\nimport BigNumber from 'bignumber.js'\nrequire('source-map-support').install()\n\nconst TEST_PACKET_AMOUNT = new BigNumber(1000)\nconst RETRY_DELAY_START = 100\nconst MAX_DATA_SIZE = 32767\nconst DEFAULT_MAX_REMOTE_STREAMS = 10\n\nexport interface ConnectionOpts {\n  /**\n   * Ledger plugin (V2). If a plugin is not supplied, it defaults to using the [ILP Plugin](https://github.com/interledgerjs/ilp-plugin)\n   * module to get the plugin details from the environment\n   */\n  plugin?: Plugin,\n  /** ILP Address of the remote entity */\n  destinationAccount?: string,\n  /** ILP Address of the plugin */\n  sourceAccount?: string,\n  /** Specifies how much worse than the initial test packet that the exchange rate is allowed to get before packets are rejected */\n  slippage?: BigNumber.Value,\n  /** Pad packets to the maximum size (data field of 32767 bytes). False by default */\n  enablePadding?: boolean,\n  /** User-specified connection identifier that was passed into [`generateAddressAndSecret`]{@link Server#generateAddressAndSecret} */\n  connectionTag?: string,\n  /** Maximum number of streams the other entity can have open at once. Defaults to 10 */\n  maxRemoteStreams?: number,\n  /** Number of bytes each connection can have in the buffer. Defaults to 65534 */\n  connectionBufferSize?: number\n}\n\nexport interface FullConnectionOpts extends ConnectionOpts {\n  sourceAccount: string,\n  isServer: boolean,\n  /** Shared secret generated by the server with [`generateAddressAndSecret`]{@link Server#generateAddressAndSecret} */\n  sharedSecret: Buffer,\n  plugin: Plugin\n}\n\nexport class ConnectionError extends Error {\n  streamErrorCode: ErrorCode\n\n  constructor (message: string, streamErrorCode?: ErrorCode) {\n    super(message)\n    this.streamErrorCode = streamErrorCode || ErrorCode.InternalError\n  }\n}\n\n/**\n * Class representing the connection between a [`Client`]{@link createConnection} and a [`Server`]{@link Server}.\n * A single connection can be used to send or receive on [Streams]{@link DataAndMoneyStream}.\n *\n * Streams are created using the [`createStream`]{@link createStream} method.\n * The `'stream'` event will be emitted whenever a new incoming stream is opened by the other party.\n */\nexport class Connection extends EventEmitter {\n  /** Application identifier for a certain connection */\n  readonly connectionTag?: string\n\n  protected plugin: Plugin\n  protected sourceAccount: string\n  protected destinationAccount?: string\n  protected sharedSecret: Buffer\n  protected isServer: boolean\n  protected slippage: BigNumber\n  protected allowableReceiveExtra: BigNumber\n  protected enablePadding: boolean\n  protected maxBufferedData: number\n\n  protected nextPacketSequence: number\n  protected streams: Map<number, DataAndMoneyStream>\n  protected nextStreamId: number\n  protected maxStreamId: number\n  protected debug: Debug.IDebugger\n  protected sending: boolean\n  /** Used to probe for the Maximum Packet Amount if the connectors don't tell us directly */\n  protected testMaximumPacketAmount: BigNumber\n  /** The path's Maximum Packet Amount, discovered through F08 errors */\n  protected maximumPacketAmount: BigNumber\n  protected closed: boolean\n  protected exchangeRate?: BigNumber\n  protected retryDelay: number\n  protected queuedFrames: Frame[]\n\n  protected remoteClosed: boolean\n  protected remoteMaxStreamId: number\n  protected remoteKnowsOurAccount: boolean\n\n  // TODO use bignumbers for byte offsets\n  protected remoteMaxOffset: number\n  protected _totalReceived: BigNumber\n  protected _totalSent: BigNumber\n  protected _totalDelivered: BigNumber\n  protected _lastPacketExchangeRate: BigNumber\n\n  constructor (opts: FullConnectionOpts) {\n    super()\n    this.plugin = opts.plugin\n    this.sourceAccount = opts.sourceAccount\n    this.destinationAccount = opts.destinationAccount\n    this.sharedSecret = opts.sharedSecret\n    this.isServer = opts.isServer\n    this.slippage = new BigNumber(opts.slippage || 0)\n    this.allowableReceiveExtra = new BigNumber(1.01)\n    this.enablePadding = !!opts.enablePadding\n    this.connectionTag = opts.connectionTag\n    this.maxStreamId = 2 * (opts.maxRemoteStreams || DEFAULT_MAX_REMOTE_STREAMS)\n    this.maxBufferedData = opts.connectionBufferSize || MAX_DATA_SIZE * 2\n\n    this.nextPacketSequence = 1\n    this.streams = new Map()\n    this.nextStreamId = (this.isServer ? 2 : 1)\n    this.debug = Debug(`ilp-protocol-stream:${this.isServer ? 'Server' : 'Client'}:Connection`)\n    this.sending = false\n    this.closed = true\n    this.queuedFrames = []\n\n    this.maximumPacketAmount = new BigNumber(Infinity)\n    this.testMaximumPacketAmount = new BigNumber(Infinity)\n    this.retryDelay = RETRY_DELAY_START\n\n    this.remoteClosed = false\n    this.remoteKnowsOurAccount = this.isServer\n    this.remoteMaxStreamId = DEFAULT_MAX_REMOTE_STREAMS\n\n    this.remoteMaxOffset = this.maxBufferedData\n\n    this._totalReceived = new BigNumber(0)\n    this._totalSent = new BigNumber(0)\n    this._totalDelivered = new BigNumber(0)\n    this._lastPacketExchangeRate = new BigNumber(0)\n  }\n\n  /**\n   * New incoming stream event\n   * @event stream\n   * @type {DataAndMoneyStream}\n   */\n\n  /**\n   * Start sending or receiving.\n   * @fires stream\n   */\n  async connect (): Promise<void> {\n    if (!this.closed) {\n      return Promise.resolve()\n    }\n    /* tslint:disable-next-line:no-floating-promises */\n    this.startSendLoop()\n    await new Promise((resolve, reject) => {\n      const connectHandler = () => {\n        cleanup()\n        resolve()\n      }\n      const closeHandler = () => {\n        cleanup()\n        reject(new Error('Connection was closed before it was connected'))\n      }\n      const errorHandler = (error?: Error) => {\n        cleanup()\n        reject(new Error(`Error connecting${error ? ': ' + error.message : ''}`))\n      }\n      this.once('connect', connectHandler)\n      this.once('error', errorHandler)\n      this.once('close', closeHandler)\n      this.once('end', closeHandler)\n\n      const self = this\n      function cleanup () {\n        self.removeListener('connect', connectHandler)\n        self.removeListener('error', errorHandler)\n        self.removeListener('close', closeHandler)\n        self.removeListener('end', closeHandler)\n      }\n    })\n    this.closed = false\n  }\n\n  /**\n   * Close the connection when all streams have finished sending their money and data\n   */\n  // TODO should this be sync or async?\n  async end (): Promise<void> {\n    this.debug('closing connection')\n    this.closed = true\n\n    for (let [_, stream] of this.streams) {\n      if (stream.isOpen()) {\n        stream.end()\n        // TODO should this mark the remoteStreams as closed?\n      }\n    }\n\n    await new Promise((resolve, reject) => {\n      this.once('_send_loop_finished', resolve)\n      this.once('error', reject)\n\n      /* tslint:disable-next-line:no-floating-promises */\n      this.startSendLoop()\n    })\n    await this.sendConnectionClose()\n    this.safeEmit('end')\n    this.safeEmit('close')\n  }\n\n  /**\n   * Immediately close the connection and all streams\n   */\n  // TODO should this be sync or async?\n  async destroy (err?: Error): Promise<void> {\n    this.debug('destroying connection with error:', err)\n    if (err) {\n      this.safeEmit('error', err)\n    }\n    for (let [_, stream] of this.streams) {\n      // TODO should we pass the error to each stream?\n      stream.destroy()\n    }\n    await this.sendConnectionClose(err)\n    this.safeEmit('close')\n  }\n\n  /**\n   * Returns a new bidirectional [`DataAndMoneyStream`]{@link DataAndMoneyStream}\n   */\n  createStream (): DataAndMoneyStream {\n    // Make sure we don't open more streams than the remote will allow\n    if (this.remoteMaxStreamId < this.nextStreamId) {\n      this.debug(`cannot creat another stream. nextStreamId: ${this.nextStreamId}, remote maxStreamId: ${this.remoteMaxStreamId}`)\n      this.queuedFrames.push(new ConnectionStreamIdBlockedFrame(this.nextStreamId))\n      throw new Error(`Creating another stream would exceed the remote connection's maximum number of open streams`)\n    }\n\n    // TODO should this inform the other side?\n    const stream = new DataAndMoneyStream({\n      id: this.nextStreamId,\n      isServer: this.isServer\n    })\n    this.streams.set(this.nextStreamId, stream)\n    this.debug(`created stream: ${this.nextStreamId}`)\n    this.nextStreamId += 2\n\n    stream.on('_maybe_start_send_loop', this.startSendLoop.bind(this))\n    // TODO notify when the stream is closed\n\n    return stream\n  }\n\n  /**\n   * Connections minimum exchange rate with slippage included, if not set '0' is returned.\n   */\n  get minimumAcceptableExchangeRate (): string {\n    if (this.exchangeRate) {\n      const minimumExchangeWithSlippage = this.exchangeRate\n         .times(new BigNumber(1).minus(this.slippage))\n      return minimumExchangeWithSlippage.toString()\n    }\n    return '0'\n  }\n\n /**\n  * Calculates the last exchange rate based on last packet successfully sent.\n  */\n  get lastPacketExchangeRate (): string {\n    return this._lastPacketExchangeRate.toString()\n  }\n\n  /**\n   * Total delivered so far, denominated in the connection plugin's units.\n   */\n  get totalDelivered (): string {\n    return this._totalDelivered.toString()\n  }\n\n  /**\n   * Total sent so far, denominated in the connection plugin's units.\n   */\n  get totalSent (): string {\n    return this._totalSent.toString()\n  }\n\n  /**\n   * Total received so far by the local side, denominated in the connection plugin's units.\n   */\n  get totalReceived (): string {\n    return this._totalReceived.toString()\n  }\n\n  /**\n   * (Internal) Handle incoming ILP Prepare packets.\n   * This will automatically fulfill all valid and expected Prepare packets.\n   * It passes the incoming money and/or data to the relevant streams.\n   * @private\n   */\n  async handlePrepare (prepare: IlpPacket.IlpPrepare): Promise<IlpPacket.IlpFulfill> {\n    // Parse packet\n    let requestPacket: Packet\n    try {\n      requestPacket = Packet.decryptAndDeserialize(this.sharedSecret, prepare.data)\n    } catch (err) {\n      this.debug(`error parsing frames:`, err)\n      throw new IlpPacket.Errors.UnexpectedPaymentError('')\n    }\n    this.debug('handling packet:', JSON.stringify(requestPacket))\n\n    if (requestPacket.ilpPacketType.valueOf() !== IlpPacket.Type.TYPE_ILP_PREPARE) {\n      this.debug(`prepare packet contains a frame that says it should be something other than a prepare: ${requestPacket.ilpPacketType}`)\n      throw new IlpPacket.Errors.UnexpectedPaymentError('')\n    }\n\n    let responseFrames: Frame[] = []\n\n    // Tell peer how much data connection can receive\n    responseFrames.push(new ConnectionMaxDataFrame(this.getIncomingOffsets().maxAcceptable))\n\n    const throwFinalApplicationError = () => {\n      responseFrames = responseFrames.concat(this.queuedFrames)\n      this.queuedFrames = []\n      const responsePacket = new Packet(requestPacket.sequence, IlpPacketType.Reject, prepare.amount, responseFrames)\n      this.debug(`rejecting packet ${requestPacket.sequence}: ${JSON.stringify(responsePacket)}`)\n      throw new IlpPacket.Errors.FinalApplicationError('', responsePacket.serializeAndEncrypt(this.sharedSecret, (this.enablePadding ? MAX_DATA_SIZE : undefined)))\n    }\n\n    try {\n      this.handleFrames(requestPacket.frames)\n    } catch (err) {\n      this.debug('error handling frames:', err)\n      throwFinalApplicationError()\n    }\n\n    // TODO keep a running total of the offsets so we don't need to recalculate each time\n    const incomingOffsets = this.getIncomingOffsets()\n    if (incomingOffsets.max > incomingOffsets.maxAcceptable) {\n      /* tslint:disable-next-line:no-floating-promises */\n      this.destroy(new ConnectionError(`Exceeded flow control limits. Max connection byte offset: ${incomingOffsets.maxAcceptable}, received: ${incomingOffsets.max}`, ErrorCode.FlowControlError))\n      throwFinalApplicationError()\n    }\n\n    if (requestPacket.prepareAmount.isGreaterThan(prepare.amount)) {\n      this.debug(`received less than minimum destination amount. actual: ${prepare.amount}, expected: ${requestPacket.prepareAmount}`)\n      throwFinalApplicationError()\n    }\n\n    // Ensure we can generate correct fulfillment\n    const fulfillment = cryptoHelper.generateFulfillment(this.sharedSecret, prepare.data)\n    const generatedCondition = cryptoHelper.hash(fulfillment)\n    if (!generatedCondition.equals(prepare.executionCondition)) {\n      this.debug(`got unfulfillable prepare for amount: ${prepare.amount}. generated condition: ${generatedCondition.toString('hex')}, prepare condition: ${prepare.executionCondition.toString('hex')}`)\n      throwFinalApplicationError()\n    }\n\n    // Determine amount to receive on each frame\n    const amountsToReceive: { stream: DataAndMoneyStream, amount: BigNumber }[] = []\n    const totalMoneyShares = requestPacket.frames.reduce((sum: BigNumber, frame: Frame) => {\n      if (frame instanceof StreamMoneyFrame) {\n        return sum.plus(frame.shares)\n      }\n      return sum\n    }, new BigNumber(0))\n    for (let frame of requestPacket.frames) {\n      if (!(frame instanceof StreamMoneyFrame)) {\n        continue\n      }\n      const streamId = frame.streamId.toNumber()\n      const streamAmount = new BigNumber(prepare.amount)\n        .times(frame.shares)\n        .dividedBy(totalMoneyShares)\n        // TODO make sure we don't lose any because of rounding issues\n        .integerValue(BigNumber.ROUND_FLOOR)\n      const stream = this.streams.get(streamId)!\n      amountsToReceive.push({\n        stream,\n        amount: streamAmount\n      })\n\n      // Ensure that this amount isn't more than the stream can receive\n      const maxStreamCanReceive = stream._getAmountStreamCanReceive()\n        .times(this.allowableReceiveExtra)\n        .integerValue(BigNumber.ROUND_CEIL)\n      if (maxStreamCanReceive.isLessThan(streamAmount)) {\n        // TODO should this be distributed to other streams if it can be?\n        this.debug(`peer sent too much for stream: ${streamId}. got: ${streamAmount}, max receivable: ${maxStreamCanReceive}`)\n        // Tell peer how much the streams they sent for can receive\n        responseFrames.push(new StreamMaxMoneyFrame(streamId, stream.receiveMax, stream.totalReceived))\n\n        // TODO include error frame\n        throwFinalApplicationError()\n      }\n\n      // Reject the packet if any of the streams is already closed\n      if (!stream.isOpen()) {\n        this.debug(`peer sent money for stream that was already closed: ${streamId}`)\n        responseFrames.push(new StreamCloseFrame(streamId, ErrorCode.StreamStateError, 'Stream is already closed'))\n\n        throwFinalApplicationError()\n      }\n    }\n\n    // Add incoming amounts to each stream\n    for (let { stream, amount } of amountsToReceive) {\n      stream._addToIncoming(amount)\n    }\n\n    // Tell peer about closed streams and how much each stream can receive\n    if (!this.closed && !this.remoteClosed) {\n      for (let [_, stream] of this.streams) {\n        const streamIsClosed = !stream.isOpen() && stream._getAmountAvailableToSend().isEqualTo(0)\n        if (streamIsClosed && !stream._remoteClosed) {\n          this.debug(`telling other side that stream ${stream.id} is closed`)\n          if (stream._errorMessage) {\n            responseFrames.push(new StreamCloseFrame(stream.id, ErrorCode.ApplicationError, stream._errorMessage))\n          } else {\n            responseFrames.push(new StreamCloseFrame(stream.id, ErrorCode.NoError, ''))\n          }\n          // TODO confirm that they get this\n          stream._remoteClosed = true\n        } else {\n          this.debug(`telling other side that stream ${stream.id} can receive ${stream.receiveMax}`)\n          responseFrames.push(new StreamMaxMoneyFrame(stream.id, stream.receiveMax, stream.totalReceived))\n\n          // TODO only send these frames when we need to\n          responseFrames.push(new StreamMaxDataFrame(stream.id, stream._getIncomingOffsets().maxAcceptable))\n        }\n      }\n    }\n\n    // TODO make sure the queued frames aren't too big\n    responseFrames = responseFrames.concat(this.queuedFrames)\n    this.queuedFrames = []\n\n    // Return fulfillment and response packet\n    const responsePacket = new Packet(requestPacket.sequence, IlpPacketType.Fulfill, prepare.amount, responseFrames)\n    this._totalReceived = this._totalReceived.plus(prepare.amount)\n    this.debug(`fulfilling prepare with fulfillment: ${fulfillment.toString('hex')} and response packet: ${JSON.stringify(responsePacket)}`)\n    return {\n      fulfillment,\n      data: responsePacket.serializeAndEncrypt(this.sharedSecret, (this.enablePadding ? MAX_DATA_SIZE : undefined))\n    }\n  }\n\n  /**\n   * Parse the frames from the incoming packet and apply all effects\n   * except for passing money to the streams\n   */\n  protected handleFrames (frames: Frame[]): void {\n    for (let frame of frames) {\n      let stream\n      switch (frame.type) {\n        case FrameType.ConnectionNewAddress:\n          this.debug(`peer notified us of their account: ${frame.sourceAccount}`)\n          const firstConnection = this.destinationAccount === undefined\n          this.destinationAccount = frame.sourceAccount\n          if (firstConnection) {\n            this.handleConnect()\n          }\n          // TODO reset the exchange rate and send a test packet to make sure they haven't spoofed the address\n          break\n        case FrameType.ConnectionClose:\n          // TODO end the connection in some other way\n          this.sending = false\n          this.closed = true\n          this.remoteClosed = true\n          if (frame.errorCode === ErrorCode.NoError) {\n            this.debug(`remote closed connection`)\n            /* tslint:disable-next-line:no-floating-promises */\n            this.end()\n          } else {\n            this.debug(`remote connection error. code: ${ErrorCode[frame.errorCode]}, message: ${frame.errorMessage}`)\n            /* tslint:disable-next-line:no-floating-promises */\n            this.destroy(new Error(`Remote connection error. Code: ${ErrorCode[frame.errorCode]}, message: ${frame.errorMessage}`))\n          }\n          break\n        case FrameType.ConnectionMaxData:\n          const outgoingOffsets = this.getOutgoingOffsets()\n          this.debug(`remote connection max byte offset is: ${frame.maxOffset}, we've sent: ${outgoingOffsets.currentOffset}, we want to send up to: ${outgoingOffsets.maxOffset}`)\n          if (frame.maxOffset.isGreaterThan(MAX_DATA_SIZE * 2)) {\n            this.remoteMaxOffset = Math.max(frame.maxOffset.toNumber(), this.remoteMaxOffset)\n          } else {\n            // We assumed their size was 64kb but it turned out to be less\n            this.remoteMaxOffset = frame.maxOffset.toNumber()\n          }\n          break\n        case FrameType.ConnectionDataBlocked:\n          this.debug(`remote wants to send more data but we are blocking them. current max incoming offset: ${this.getIncomingOffsets()}, remote max offset: ${frame.maxOffset}`)\n          break\n        case FrameType.ConnectionMaxStreamId:\n          // TODO make sure the number isn't lowered\n          this.debug(`remote set max stream id to ${frame.maxStreamId}`)\n          this.remoteMaxStreamId = frame.maxStreamId.toNumber()\n          break\n        case FrameType.ConnectionStreamIdBlocked:\n          this.debug(`remote wants to open more streams but we are blocking them`)\n          break\n        case FrameType.StreamClose:\n          this.handleNewStream(frame.streamId.toNumber())\n          this.handleStreamClose(frame)\n          break\n        case FrameType.StreamMoney:\n          this.handleNewStream(frame.streamId.toNumber())\n          break\n        case FrameType.StreamMaxMoney:\n          this.handleNewStream(frame.streamId.toNumber())\n          this.debug(`peer told us that stream ${frame.streamId} can receive up to: ${frame.receiveMax} and has received: ${frame.totalReceived} so far`)\n          stream = this.streams.get(frame.streamId.toNumber())!\n          stream._remoteReceived = BigNumber.maximum(stream._remoteReceived, frame.totalReceived)\n          if (stream._remoteReceiveMax.isFinite()) {\n            stream._remoteReceiveMax = BigNumber.maximum(stream._remoteReceiveMax, frame.receiveMax)\n          } else {\n            stream._remoteReceiveMax = frame.receiveMax\n          }\n          if (stream._remoteReceiveMax.isGreaterThan(stream._remoteReceived)\n            && stream._getAmountAvailableToSend().isGreaterThan(0)) {\n            /* tslint:disable-next-line:no-floating-promises */\n            this.startSendLoop()\n          }\n          break\n        case FrameType.StreamMoneyBlocked:\n          this.handleNewStream(frame.streamId.toNumber())\n          this.debug(`peer told us that they want to send more money on stream ${frame.streamId} but we are blocking them. they have sent: ${frame.totalSent} so far and want to send: ${frame.sendMax}`)\n          break\n        case FrameType.StreamData:\n          this.handleNewStream(frame.streamId.toNumber())\n          this.debug(`got data for stream ${frame.streamId}`)\n\n          stream = this.streams.get(frame.streamId.toNumber())!\n          stream._pushIncomingData(frame.data, frame.offset.toNumber())\n\n          // Make sure the peer hasn't exceeded the flow control limits\n          const incomingOffsets = stream._getIncomingOffsets()\n          if (incomingOffsets.max > incomingOffsets.maxAcceptable) {\n            /* tslint:disable-next-line:no-floating-promises */\n            this.destroy(new ConnectionError(`Exceeded flow control limits. Stream ${stream.id} can accept up to offset: ${incomingOffsets.maxAcceptable} but got bytes up to offset: ${incomingOffsets.max}`))\n          }\n          break\n        case FrameType.StreamMaxData:\n          this.handleNewStream(frame.streamId.toNumber())\n          stream = this.streams.get(frame.streamId.toNumber())!\n          this.debug(`peer told us that stream ${frame.streamId} can receive up to byte offset: ${frame.maxOffset} (we've sent up to offset: ${stream._getOutgoingOffsets().current})`)\n          const oldOffset = stream._remoteMaxOffset\n          stream._remoteMaxOffset = frame.maxOffset.toNumber()\n          if (stream._remoteMaxOffset > oldOffset) {\n            /* tslint:disable-next-line:no-floating-promises */\n            this.startSendLoop()\n          }\n          break\n        case FrameType.StreamDataBlocked:\n          this.handleNewStream(frame.streamId.toNumber())\n          stream = this.streams.get(frame.streamId.toNumber())!\n          this.debug(`peer told us that stream ${frame.streamId} is blocked. they want to send up to offset: ${frame.maxOffset}, but we are only allowing up to: ${stream._getIncomingOffsets().maxAcceptable}`)\n          break\n        default:\n          continue\n      }\n    }\n  }\n\n  /**\n   * Handle the initial connection from the other side\n   */\n  protected handleConnect () {\n    this.closed = false\n    this.debug('connected')\n    this.safeEmit('connect')\n\n    // Tell the other side our max stream id\n    this.queuedFrames.push(new ConnectionMaxStreamIdFrame(this.maxStreamId))\n  }\n\n  /**\n   * Ensure that the new stream is valid and does not exceed our limits\n   * and if it looks good, emit the 'stream' event\n   */\n  protected handleNewStream (streamId: number): void {\n    if (this.streams.has(streamId)) {\n      return\n    }\n\n    // Validate stream ID\n    if (this.isServer && streamId % 2 === 0) {\n      this.debug(`got invalid stream ID ${streamId} from peer (should be odd)`)\n      this.queuedFrames.push(new ConnectionCloseFrame(ErrorCode.ProtocolViolation, `Invalid Stream ID: ${streamId}. Client-initiated streams must have odd-numbered IDs`))\n      // TODO this should probably call this.destroy\n      const err = new Error(`Invalid Stream ID: ${streamId}. Client-initiated streams must have odd-numbered IDs`)\n      this.safeEmit('error', err)\n      throw err\n    } else if (!this.isServer && streamId % 2 === 1) {\n      this.debug(`got invalid stream ID ${streamId} from peer (should be even)`)\n      this.queuedFrames.push(new ConnectionCloseFrame(ErrorCode.ProtocolViolation, `Invalid Stream ID: ${streamId}. Server-initiated streams must have even-numbered IDs`))\n      const err = new Error(`Invalid Stream ID: ${streamId}. Server-initiated streams must have even-numbered IDs`)\n      this.safeEmit('error', err)\n      throw err\n    }\n\n    // Make sure there aren't too many open streams\n    if (streamId > this.maxStreamId) {\n      this.debug(`peer opened too many streams. got stream: ${streamId}, but max stream id is: ${this.maxStreamId}. closing connection`)\n      this.queuedFrames.push(new ConnectionCloseFrame(ErrorCode.StreamIdError, `Maximum number of open streams exceeded. Got stream: ${streamId}, current max stream ID: ${this.maxStreamId}`))\n      const err = new Error(`Maximum number of open streams exceeded. Got stream: ${streamId}, current max stream ID: ${this.maxStreamId}`)\n      this.safeEmit('error', err)\n      throw err\n    }\n\n    // Let the other side know if they're getting close to the number of streams\n    if (this.maxStreamId * .75 < streamId) {\n      this.debug(`informing peer that our max stream id is: ${this.maxStreamId}`)\n      this.queuedFrames.push(new ConnectionMaxStreamIdFrame(this.maxStreamId))\n    }\n\n    this.debug(`got new stream: ${streamId}`)\n    const stream = new DataAndMoneyStream({\n      id: streamId,\n      isServer: this.isServer\n    })\n    this.streams.set(streamId, stream)\n    stream.on('_maybe_start_send_loop', () => this.startSendLoop())\n    this.safeEmit('stream', stream)\n  }\n\n  /**\n   * Mark the stream as closed\n   */\n  protected handleStreamClose (frame: StreamCloseFrame) {\n    const streamId = frame.streamId.toNumber()\n    const stream = this.streams.get(streamId)\n    if (!stream) {\n      this.debug(`remote error on stream ${streamId}, but we don't have a record of that stream`)\n      return\n    }\n\n    if (!stream.isOpen() || stream._remoteSentEnd) {\n      return\n    }\n\n    // TODO delete stream record and make sure the other side can't reopen it\n\n    this.debug(`peer closed stream ${stream.id} with error code: ${ErrorCode[frame.errorCode]} and message: ${frame.errorMessage}`)\n    // TODO should we confirm with the other side that we closed it?\n    stream._sentEnd = true\n    let err\n    if (frame.errorMessage) {\n      err = new Error(frame.errorMessage)\n      err.name = ErrorCode[frame.errorCode]\n    }\n    stream._remoteEnded(err)\n    // TODO should we emit an error on the stream?\n\n    // TODO make sure we don't send more than one of these frames per packet\n    this.maxStreamId += 2\n    this.debug(`raising maxStreamId to ${this.maxStreamId}`)\n    this.queuedFrames.push(new ConnectionMaxStreamIdFrame(this.maxStreamId))\n  }\n\n  /**\n   * (Internal) Start sending packets with money and/or data, as necessary.\n   * @private\n   */\n  protected async startSendLoop () {\n    if (this.sending) {\n      return\n    }\n    if (this.remoteClosed) {\n      this.debug('remote connection is already closed, not starting another loop')\n      this.safeEmit('_send_loop_finished')\n      return\n    }\n    if (!this.destinationAccount) {\n      this.debug('not sending because we do not know the client\\'s address')\n      this.sending = false\n      return\n    }\n\n    this.sending = true\n    this.debug('starting send loop')\n\n    try {\n      while (this.sending) {\n        // Send a test packet first to determine the exchange rate\n        if (!this.exchangeRate) {\n          this.debug('determining exchange rate')\n          await this.sendTestPacket()\n\n          if (this.exchangeRate) {\n            this.safeEmit('connect')\n            this.debug('connected')\n          }\n        } else {\n          // TODO Send multiple packets at the same time (don't await promise)\n          // TODO Figure out if we need to wait before sending the next one\n          await this.loadAndSendPacket()\n        }\n      }\n    } catch (err) {\n      // TODO should a connection error be an error on all of the streams?\n      return this.destroy(err)\n    }\n    this.debug('finished sending')\n    this.safeEmit('_send_loop_finished')\n    for (let [_, stream] of this.streams) {\n      stream.emit('_send_loop_finished')\n    }\n  }\n\n  /**\n   * Load up a packet money and/or data, send it to the other party, and handle the result.\n   * @private\n   */\n  protected async loadAndSendPacket (): Promise<void> {\n    // Actually send on the next tick of the event loop in case multiple streams\n    // have their limits raised at the same time\n    await new Promise((resolve, reject) => setImmediate(resolve))\n\n    this.debug('loadAndSendPacket')\n    let amountToSend = new BigNumber(0)\n\n    // Set packet number to correlate response with request\n    const requestPacket = new Packet(this.nextPacketSequence++, IlpPacketType.Prepare)\n\n    // TODO make sure these aren't too big\n    requestPacket.frames = this.queuedFrames\n    this.queuedFrames = []\n\n    // Send control frames\n    // TODO only send the max amount when it changes\n    for (let [_, stream] of this.streams) {\n      if (stream && stream.isOpen()) {\n        requestPacket.frames.push(new StreamMaxMoneyFrame(stream.id, stream.receiveMax, stream.totalReceived))\n      }\n    }\n    if (this.closed && !this.remoteClosed) {\n      // TODO how do we know if there was an error?\n      this.debug('sending connection close frame')\n      requestPacket.frames.push(new ConnectionCloseFrame(ErrorCode.NoError, ''))\n      // TODO don't put any more frames because the connection is closed\n      // TODO only mark this as closed once we confirm that with the receiver\n      this.remoteClosed = true\n    }\n\n    // Determine how much to send based on amount frames and path maximum packet amount\n    let maxAmountFromNextStream = this.testMaximumPacketAmount\n    const streamsSentFrom = []\n    for (let [_, stream] of this.streams) {\n      if (stream._sentEnd) {\n        // TODO just remove closed streams?\n        continue\n      }\n      // Determine how much to send from this stream based on how much it has available\n      // and how much the receiver side of this stream can receive\n      let amountToSendFromStream = BigNumber.minimum(stream._getAmountAvailableToSend(), maxAmountFromNextStream)\n      if (this.exchangeRate) {\n        const maxDestinationAmount = stream._remoteReceiveMax.minus(stream._remoteReceived)\n        const maxSourceAmount = maxDestinationAmount.dividedBy(this.exchangeRate).integerValue(BigNumber.ROUND_CEIL)\n        if (maxSourceAmount.isLessThan(amountToSendFromStream)) {\n          this.debug(`stream ${stream.id} could send ${amountToSendFromStream} but that would be more than the receiver says they can receive, so we'll send ${maxSourceAmount} instead`)\n          amountToSendFromStream = maxSourceAmount\n        }\n      }\n      this.debug(`amount to send from stream ${stream.id}: ${amountToSendFromStream}, exchange rate: ${this.exchangeRate}, remote total received: ${stream._remoteReceived}, remote receive max: ${stream._remoteReceiveMax}`)\n\n      // Hold the money and add a frame to the packet\n      if (amountToSendFromStream.isGreaterThan(0)) {\n        stream._holdOutgoing(requestPacket.sequence.toString(), amountToSendFromStream)\n        // TODO make sure the length of the frames doesn't exceed packet data limit\n        requestPacket.frames.push(new StreamMoneyFrame(stream.id, amountToSendFromStream))\n        amountToSend = amountToSend.plus(amountToSendFromStream)\n        maxAmountFromNextStream = maxAmountFromNextStream.minus(amountToSendFromStream)\n        streamsSentFrom.push(stream)\n      }\n\n      // Tell peer if they're blocking us from sending money\n      const amountLeftStreamWantsToSend = new BigNumber(stream.sendMax).minus(stream.totalSent).minus(amountToSendFromStream)\n      /* tslint:disable-next-line:no-unnecessary-type-assertion */\n      if (amountLeftStreamWantsToSend.times(this.exchangeRate!).isGreaterThan(stream._remoteReceiveMax.minus(stream._remoteReceived))) {\n        requestPacket.frames.push(new StreamMoneyBlockedFrame(stream.id, stream.sendMax, stream.totalSent))\n      }\n\n      if (maxAmountFromNextStream.isEqualTo(0)) {\n        // TODO make sure that we start with those later frames the next time around\n        break\n      }\n    }\n\n    // Send data\n    let sendingData = false\n    let bytesLeftInPacket = MAX_DATA_SIZE - requestPacket.byteLength()\n\n    // Respect connection-level flow control\n    const maxBytesRemoteConnectionCanReceive = this.remoteMaxOffset - this.getOutgoingOffsets().currentOffset\n    if (bytesLeftInPacket > maxBytesRemoteConnectionCanReceive) {\n      const outgoingMaxOffset = this.getOutgoingOffsets().maxOffset\n      this.debug(`peer is blocking us from sending more data. they will only accept up to offset: ${this.remoteMaxOffset}, but we want to send up to: ${outgoingMaxOffset}`)\n      requestPacket.frames.push(new ConnectionDataBlockedFrame(outgoingMaxOffset))\n      bytesLeftInPacket = maxBytesRemoteConnectionCanReceive\n    }\n\n    for (let [_, stream] of this.streams) {\n      // TODO use a sensible estimate for the StreamDataFrame overhead\n      const { data, offset } = stream._getAvailableDataToSend(bytesLeftInPacket - 20)\n      if (data && data.length > 0) {\n        const streamDataFrame = new StreamDataFrame(stream.id, offset, data)\n        this.debug(`sending ${data.length} bytes from stream ${stream.id}`)\n        bytesLeftInPacket -= streamDataFrame.byteLength()\n        requestPacket.frames.push(streamDataFrame)\n        // TODO actually figure out if there's more data to send\n        sendingData = true\n      }\n\n      // Inform remote which streams are blocked\n      const maxOutgoingOffset = stream._isDataBlocked()\n      if (maxOutgoingOffset) {\n        this.debug(`telling remote that stream ${stream.id} is blocked and has more data to send`)\n        requestPacket.frames.push(new StreamDataBlockedFrame(stream.id, maxOutgoingOffset))\n      }\n    }\n\n    // Stop sending if there's no more to send\n    // TODO don't stop if there's still data to send\n    if (amountToSend.isEqualTo(0) && !sendingData) {\n      this.debug(`packet value is 0 and there is no data to send so we'll send this packet and then stop`)\n      this.sending = false\n      // TODO figure out if there are control frames we need to send and stop sending if not\n    }\n\n    // Tell other side which streams are closed\n    if (!this.closed) {\n      for (let [_, stream] of this.streams) {\n        if (stream.isOpen() || stream._sentEnd) {\n          continue\n        }\n        if (stream._getAmountAvailableToSend().isGreaterThan(0)) {\n          this.debug(`stream ${stream.id} is closed but still has money to send, not sending end frame yet`)\n          continue\n        }\n        if (stream._hasDataToSend()) {\n          this.debug(`stream ${stream.id} is closed but still has data to send, not sending end frame yet`)\n          continue\n        }\n        const streamEndFrame = (stream._errorMessage\n          ? new StreamCloseFrame(stream.id, ErrorCode.ApplicationError, stream._errorMessage)\n          : new StreamCloseFrame(stream.id, ErrorCode.NoError, ''))\n\n        // Make sure the packet has space left\n        if (streamEndFrame.byteLength() > bytesLeftInPacket) {\n          // TODO make sure it will actually make another pass to send these later\n          this.debug('not sending more stream end frames because the packet is full')\n          break\n        }\n        this.debug(`sending end frame for stream ${stream.id}`)\n        // TODO should this be a Stream{Money,Data} frame with isEnd set instead?\n        requestPacket.frames.push(streamEndFrame)\n        bytesLeftInPacket -= streamEndFrame.byteLength()\n        // TODO only set this to true if the packet gets through to the receiver\n        stream._sentEnd = true\n      }\n    }\n\n    // Set minimum destination amount\n    if (this.exchangeRate) {\n      const minimumDestinationAmount = amountToSend.times(this.exchangeRate)\n        .times(new BigNumber(1).minus(this.slippage))\n        .integerValue(BigNumber.ROUND_FLOOR)\n      if (minimumDestinationAmount.isGreaterThan(0)) {\n        requestPacket.prepareAmount = minimumDestinationAmount\n      }\n    }\n\n    if (amountToSend.isEqualTo(0) && requestPacket.frames.length === 0) {\n      this.debug(`no money or data needs to be send, stopping loop`)\n      this.sending = false\n      return\n    }\n\n    const responsePacket = await this.sendPacket(requestPacket, amountToSend, false)\n\n    if (responsePacket) {\n      this.handleFrames(responsePacket.frames)\n\n      // Track the exchange rate for the last packet (whether it was fulfilled or rejected)\n      if (amountToSend.isGreaterThan(0)) {\n        this._lastPacketExchangeRate = responsePacket.prepareAmount.dividedBy(amountToSend)\n      }\n\n      if (responsePacket.ilpPacketType === IlpPacketType.Fulfill) {\n        for (let stream of streamsSentFrom) {\n          stream._executeHold(requestPacket.sequence.toString())\n        }\n\n        // Update stats based on amount sent\n        this._totalDelivered = this._totalDelivered.plus(responsePacket.prepareAmount)\n        this._totalSent = this._totalSent.plus(amountToSend)\n\n        // If we're trying to pinpoint the Maximum Packet Amount, raise\n        // the limit because we know that the testMaximumPacketAmount works\n        if (this.maximumPacketAmount.isFinite()\n          && amountToSend.isEqualTo(this.testMaximumPacketAmount)\n          && this.testMaximumPacketAmount.isLessThan(this.maximumPacketAmount)) {\n          const newTestMax = this.maximumPacketAmount.plus(this.testMaximumPacketAmount).dividedToIntegerBy(2)\n          this.debug(`maximum packet amount is between ${this.testMaximumPacketAmount} and ${this.maximumPacketAmount}, trying: ${newTestMax}`)\n          this.testMaximumPacketAmount = newTestMax\n        }\n\n        // Reset the retry delay\n        this.retryDelay = RETRY_DELAY_START\n      }\n    }\n  }\n\n  /**\n   * (Internal) Send an unfulfillable test packet. Primarily used for determining the path exchange rate.\n   * @private\n   */\n  protected async sendTestPacket (amount?: BigNumber): Promise<void> {\n    this.debug('sendTestPacket')\n    if (!this.destinationAccount) {\n      throw new Error('Cannot send test packet. Destination account is unknown')\n    }\n\n    // Set packet number to correlate response with request\n    const requestPacket = new Packet(this.nextPacketSequence++, IlpPacketType.Prepare)\n\n    if (!this.remoteKnowsOurAccount) {\n      this.debug('sending source address to peer')\n      // TODO attach a token to the account?\n      requestPacket.frames.push(new ConnectionNewAddressFrame(this.sourceAccount))\n    }\n\n    const sourceAmount = amount || BigNumber.minimum(TEST_PACKET_AMOUNT, this.testMaximumPacketAmount)\n\n    const responsePacket = await this.sendPacket(requestPacket, sourceAmount, true)\n    if (!responsePacket) {\n      return\n    }\n\n    this.remoteKnowsOurAccount = true\n\n    // Determine exchange rate from amount that arrived\n    this.exchangeRate = responsePacket.prepareAmount.dividedBy(sourceAmount)\n    this.debug(`determined exchange rate to be: ${this.exchangeRate}`)\n    if (this.exchangeRate.isEqualTo(0)) {\n      // TODO this could also happen if the exchange rate is less than 1 / TEST_PACKET_AMOUNT\n      throw new Error('Exchange rate is 0. We will not be able to send anything through this path')\n    }\n\n    this.handleFrames(responsePacket.frames)\n  }\n\n  /**\n   * Send a ConnectionClose frame to the other side\n   */\n  protected async sendConnectionClose (err?: ConnectionError | Error): Promise<void> {\n    if (this.remoteClosed) {\n      this.debug('not sending connection error because remote is already closed')\n      return\n    }\n\n    let errorCode: ErrorCode\n    let errorMessage\n    if (err && err instanceof ConnectionError) {\n      errorCode = err.streamErrorCode\n      errorMessage = err.message\n    } else if (err) {\n      errorCode = ErrorCode.InternalError\n      errorMessage = err.message\n    } else {\n      errorCode = ErrorCode.NoError\n      errorMessage = ''\n    }\n\n    const packet = new Packet(this.nextPacketSequence, IlpPacketType.Prepare, 0, [\n      new ConnectionCloseFrame(errorCode, errorMessage)\n    ])\n    try {\n      await this.sendPacket(packet, new BigNumber(0), true)\n    } catch (err) {\n      this.debug(`error while trying to inform peer that connection is closing, but closing anyway`, err)\n    }\n    this.remoteClosed = true\n  }\n\n  /**\n   * Helper function used to send all ILP Prepare packets.\n   * This automatically generates the condition and sets the packet expiry.\n   * It also ensures that responses are valid and match the outgoing request.\n   */\n  protected async sendPacket (packet: Packet, sourceAmount: BigNumber, unfulfillable = false): Promise<Packet | void> {\n    this.debug(`sending packet ${packet.sequence} with source amount: ${sourceAmount}: ${JSON.stringify(packet)})`)\n    const data = packet.serializeAndEncrypt(this.sharedSecret, (this.enablePadding ? MAX_DATA_SIZE : undefined))\n\n    let fulfillment: Buffer | undefined\n    let executionCondition: Buffer\n    if (unfulfillable) {\n      fulfillment = undefined\n      executionCondition = cryptoHelper.generateRandomCondition()\n    } else {\n      fulfillment = cryptoHelper.generateFulfillment(this.sharedSecret, data)\n      executionCondition = cryptoHelper.hash(fulfillment)\n    }\n    const prepare = {\n      destination: this.destinationAccount!,\n      amount: (sourceAmount).toString(),\n      data,\n      executionCondition,\n      expiresAt: new Date(Date.now() + 30000)\n    }\n\n    const responseData = await this.plugin.sendData(IlpPacket.serializeIlpPrepare(prepare))\n\n    let response: IlpPacket.IlpFulfill | IlpPacket.IlpRejection\n    try {\n      if (responseData[0] === IlpPacket.Type.TYPE_ILP_FULFILL) {\n        response = IlpPacket.deserializeIlpFulfill(responseData)\n      } else if (responseData[0] === IlpPacket.Type.TYPE_ILP_REJECT) {\n        response = IlpPacket.deserializeIlpReject(responseData)\n      } else {\n        throw new Error(`Invalid response packet type: ${responseData[0]}`)\n      }\n    } catch (err) {\n      this.debug(`got invalid response from sending packet ${packet.sequence}:`, err, responseData.toString('hex'))\n      throw new Error(`Invalid response when sending packet ${packet.sequence}: ${err.message}`)\n    }\n\n    // Handle fulfillment\n    if (fulfillment && isFulfill(response)) {\n      if (!cryptoHelper.hash(response.fulfillment).equals(executionCondition)) {\n        this.debug(`got invalid fulfillment for packet ${packet.sequence}: ${response.fulfillment.toString('hex')}. expected: ${fulfillment.toString('hex')} for condition: ${executionCondition.toString('hex')}`)\n        throw new Error(`Got invalid fulfillment for packet ${packet.sequence}. Actual: ${response.fulfillment.toString('hex')}, expected: ${fulfillment.toString('hex')}`)\n      }\n    } else {\n      response = response as IlpPacket.IlpRejection\n\n      this.undoRejectedPacket(packet)\n\n      if (response.code !== 'F99') {\n        return this.handleConnectorError(response, sourceAmount)\n      }\n    }\n\n    // TODO correctly handle fulfills that come back without data attached (this will be treated like a reject)\n    if (response.data.length === 0) {\n      return undefined\n    }\n\n    // Parse response data from receiver\n    let responsePacket: Packet\n    try {\n      responsePacket = Packet.decryptAndDeserialize(this.sharedSecret, response.data)\n    } catch (err) {\n      this.debug(`unable to decrypt and parse response data:`, err, response.data.toString('hex'))\n      // TODO should we continue processing anyway? what if it was fulfilled?\n      throw new Error('Unable to decrypt and parse response data: ' + err.message)\n    }\n\n    // Ensure the response corresponds to the request\n    if (!responsePacket.sequence.isEqualTo(packet.sequence)) {\n      this.debug(`response packet sequence does not match the request packet. expected sequence: ${packet.sequence}, got response packet:`, JSON.stringify(responsePacket))\n      throw new Error(`Response packet sequence does not correspond to the request. Actual: ${responsePacket.sequence}, expected: ${packet.sequence}`)\n    }\n    if (responsePacket.ilpPacketType !== responseData[0]) {\n      this.debug(`response packet was on wrong ILP packet type. expected ILP packet type: ${responseData[0]}, got:`, JSON.stringify(responsePacket))\n      throw new Error(`Response says it should be on an ILP packet of type: ${responsePacket.ilpPacketType} but it was carried on an ILP packet of type: ${responseData[0]}`)\n    }\n\n    this.debug(`got response to packet: ${packet.sequence}: ${JSON.stringify(responsePacket)}`)\n\n    return responsePacket\n  }\n\n  /**\n   * Roll back the effects of an outgoing packet that was rejected\n   * @private\n   */\n  protected undoRejectedPacket (requestPacket: Packet) {\n    this.debug(`packet ${requestPacket.sequence} was rejected`)\n\n    // TODO resend control frames\n    for (let frame of requestPacket.frames) {\n      switch (frame.type) {\n        case FrameType.StreamMoney:\n          this.streams.get(frame.streamId.toNumber())!._cancelHold(requestPacket.sequence.toString())\n          break\n        case FrameType.StreamData:\n          this.streams.get(frame.streamId.toNumber())!._resendOutgoingData(frame.data, frame.offset.toNumber())\n          break\n        default:\n          continue\n      }\n    }\n  }\n\n  /**\n   * (Internal) Handle final and temporary errors that were not generated by the receiver.\n   * @private\n   */\n  protected async handleConnectorError (reject: IlpPacket.IlpRejection, amountSent: BigNumber) {\n    this.debug(`handling reject:`, JSON.stringify(reject))\n    if (reject.code === 'F08') {\n      let receivedAmount\n      let maximumAmount\n      try {\n        const reader = Reader.from(reject.data)\n        receivedAmount = reader.readUInt64BigNum()\n        maximumAmount = reader.readUInt64BigNum()\n      } catch (err) {\n        receivedAmount = undefined\n        maximumAmount = undefined\n      }\n      if (receivedAmount && maximumAmount && receivedAmount.isGreaterThan(maximumAmount)) {\n        const newMaximum = amountSent\n          .times(maximumAmount)\n          .dividedToIntegerBy(receivedAmount)\n        this.debug(`reducing maximum packet amount from ${this.maximumPacketAmount} to ${newMaximum}`)\n        this.maximumPacketAmount = newMaximum\n        this.testMaximumPacketAmount = newMaximum\n      } else {\n        // Connector didn't include amounts\n        this.maximumPacketAmount = amountSent.minus(1)\n        this.testMaximumPacketAmount = this.maximumPacketAmount.dividedToIntegerBy(2)\n      }\n      if (this.maximumPacketAmount.isEqualTo(0)) {\n        this.debug(`cannot send anything through this path. the maximum packet amount is 0`)\n        throw new Error('Cannot send. Path has a Maximum Packet Amount of 0')\n      }\n    } else if (reject.code[0] === 'T') {\n      this.debug(`got temporary error. waiting ${this.retryDelay} before trying again`)\n      const delay = this.retryDelay\n      this.retryDelay = this.retryDelay * 2\n      await new Promise((resolve, reject) => setTimeout(resolve, delay))\n    } else {\n      this.debug(`unexpected error. code: ${reject.code}, message: ${reject.message}, data: ${reject.data.toString('hex')}`)\n      throw new Error(`Unexpected error while sending packet. Code: ${reject.code}, message: ${reject.message}`)\n    }\n  }\n\n  protected safeEmit (event: string, ...args: any[]) {\n    try {\n      args.unshift(event)\n      this.emit.apply(this, args)\n    } catch (err) {\n      this.debug(`error in ${event} handler:`, err)\n    }\n  }\n\n  protected getOutgoingOffsets (): { currentOffset: number, maxOffset: number } {\n    let currentOffset = 0\n    let maxOffset = 0\n\n    for (let [_, stream] of this.streams) {\n      const streamOffsets = stream._getOutgoingOffsets()\n      currentOffset += streamOffsets.current\n      maxOffset += streamOffsets.max\n    }\n    return {\n      currentOffset,\n      maxOffset\n    }\n  }\n\n  protected getIncomingOffsets (): { current: number, max: number, maxAcceptable: number } {\n    let totalMaxOffset = 0\n    let totalReadOffset = 0\n    let totalBufferedData = 0\n    for (let [_, stream] of this.streams) {\n      const { max, current } = stream._getIncomingOffsets()\n      totalMaxOffset += max\n      totalReadOffset += current\n      totalBufferedData += stream.readableLength\n    }\n\n    return {\n      current: totalReadOffset,\n      max: totalMaxOffset,\n      maxAcceptable: totalReadOffset - totalBufferedData + this.maxBufferedData\n    }\n  }\n}\n\nfunction isFulfill (packet: IlpPacket.IlpFulfill | IlpPacket.IlpRejection): packet is IlpPacket.IlpFulfill {\n  return packet.hasOwnProperty('fulfillment')\n}\n"]}