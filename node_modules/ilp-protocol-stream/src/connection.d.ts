/// <reference types="node" />
/// <reference types="debug" />
import { EventEmitter } from 'events';
import * as Debug from 'debug';
import { DataAndMoneyStream } from './stream';
import * as IlpPacket from 'ilp-packet';
import { Packet, Frame, StreamCloseFrame, ErrorCode } from './packet';
import { Plugin } from './util/plugin-interface';
import BigNumber from 'bignumber.js';
export interface ConnectionOpts {
    plugin?: Plugin;
    destinationAccount?: string;
    sourceAccount?: string;
    slippage?: BigNumber.Value;
    enablePadding?: boolean;
    connectionTag?: string;
    maxRemoteStreams?: number;
    connectionBufferSize?: number;
}
export interface FullConnectionOpts extends ConnectionOpts {
    sourceAccount: string;
    isServer: boolean;
    sharedSecret: Buffer;
    plugin: Plugin;
}
export declare class ConnectionError extends Error {
    streamErrorCode: ErrorCode;
    constructor(message: string, streamErrorCode?: ErrorCode);
}
export declare class Connection extends EventEmitter {
    readonly connectionTag?: string;
    protected plugin: Plugin;
    protected sourceAccount: string;
    protected destinationAccount?: string;
    protected sharedSecret: Buffer;
    protected isServer: boolean;
    protected slippage: BigNumber;
    protected allowableReceiveExtra: BigNumber;
    protected enablePadding: boolean;
    protected maxBufferedData: number;
    protected nextPacketSequence: number;
    protected streams: Map<number, DataAndMoneyStream>;
    protected nextStreamId: number;
    protected maxStreamId: number;
    protected debug: Debug.IDebugger;
    protected sending: boolean;
    protected testMaximumPacketAmount: BigNumber;
    protected maximumPacketAmount: BigNumber;
    protected closed: boolean;
    protected exchangeRate?: BigNumber;
    protected retryDelay: number;
    protected queuedFrames: Frame[];
    protected remoteClosed: boolean;
    protected remoteMaxStreamId: number;
    protected remoteKnowsOurAccount: boolean;
    protected remoteMaxOffset: number;
    protected _totalReceived: BigNumber;
    protected _totalSent: BigNumber;
    protected _totalDelivered: BigNumber;
    protected _lastPacketExchangeRate: BigNumber;
    constructor(opts: FullConnectionOpts);
    connect(): Promise<void>;
    end(): Promise<void>;
    destroy(err?: Error): Promise<void>;
    createStream(): DataAndMoneyStream;
    readonly minimumAcceptableExchangeRate: string;
    readonly lastPacketExchangeRate: string;
    readonly totalDelivered: string;
    readonly totalSent: string;
    readonly totalReceived: string;
    handlePrepare(prepare: IlpPacket.IlpPrepare): Promise<IlpPacket.IlpFulfill>;
    protected handleFrames(frames: Frame[]): void;
    protected handleConnect(): void;
    protected handleNewStream(streamId: number): void;
    protected handleStreamClose(frame: StreamCloseFrame): void;
    protected startSendLoop(): Promise<void>;
    protected loadAndSendPacket(): Promise<void>;
    protected sendTestPacket(amount?: BigNumber): Promise<void>;
    protected sendConnectionClose(err?: ConnectionError | Error): Promise<void>;
    protected sendPacket(packet: Packet, sourceAmount: BigNumber, unfulfillable?: boolean): Promise<Packet | void>;
    protected undoRejectedPacket(requestPacket: Packet): void;
    protected handleConnectorError(reject: IlpPacket.IlpRejection, amountSent: BigNumber): Promise<void>;
    protected safeEmit(event: string, ...args: any[]): void;
    protected getOutgoingOffsets(): {
        currentOffset: number;
        maxOffset: number;
    };
    protected getIncomingOffsets(): {
        current: number;
        max: number;
        maxAcceptable: number;
    };
}
