{"version":3,"file":"index.js","sourceRoot":"","sources":["index.ts"],"names":[],"mappings":"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","sourcesContent":["import { EventEmitter } from 'events'\nimport * as ILDCP from 'ilp-protocol-ildcp'\nimport * as IlpPacket from 'ilp-packet'\nimport * as Debug from 'debug'\nimport * as cryptoHelper from './crypto'\nimport { randomBytes } from 'crypto'\nimport { Connection, ConnectionOpts } from './connection'\nimport { Plugin } from './util/plugin-interface'\nconst getPluginFromEnvironment = require('ilp-plugin')\nrequire('source-map-support').install()\n\nconst CONNECTION_ID_REGEX = /^[a-zA-Z0-9_-]+$/\n\nexport interface CreateConnectionOpts extends ConnectionOpts {\n  /** ILP Address of the server */\n  destinationAccount: string,\n  /** Shared secret generated by the server */\n  sharedSecret: Buffer\n}\n\n/**\n * Create a [`Connection`]{@link Connection} to a [`Server`]{@link Server} using the `destinationAccount` and `sharedSecret` provided.\n */\nexport async function createConnection (opts: CreateConnectionOpts): Promise<Connection> {\n  const plugin = opts.plugin || getPluginFromEnvironment() as Plugin\n  await plugin.connect()\n  const debug = Debug('ilp-protocol-stream:Client')\n  const sourceAccount = (await ILDCP.fetch(plugin.sendData.bind(plugin))).clientAddress\n  const connection = new Connection({\n    ...opts,\n    sourceAccount,\n    isServer: false,\n    plugin\n  })\n  plugin.registerDataHandler(async (data: Buffer): Promise<Buffer> => {\n    let prepare: IlpPacket.IlpPrepare\n    try {\n      prepare = IlpPacket.deserializeIlpPrepare(data)\n    } catch (err) {\n      debug(`got data that is not an ILP Prepare packet: ${data.toString('hex')}`)\n      return IlpPacket.serializeIlpReject({\n        code: 'F00',\n        message: `Expected an ILP Prepare packet (type 12), but got packet with type: ${data[0]}`,\n        data: Buffer.alloc(0),\n        triggeredBy: sourceAccount\n      })\n    }\n\n    try {\n      const fulfill = await connection.handlePrepare(prepare)\n      return IlpPacket.serializeIlpFulfill(fulfill)\n    } catch (err) {\n      if (!err.ilpErrorCode) {\n        debug('error handling prepare:', err)\n      }\n      // TODO should the default be F00 or T00?\n      return IlpPacket.serializeIlpReject({\n        code: err.ilpErrorCode || 'F00',\n        message: err.ilpErrorMessage || '',\n        data: err.ilpErrorData || Buffer.alloc(0),\n        triggeredBy: sourceAccount\n      })\n    }\n  })\n  connection.once('close', () => {\n    plugin.deregisterDataHandler()\n    plugin.disconnect()\n      .then(() => debug('plugin disconnected'))\n      .catch((err: Error) => debug('error disconnecting plugin:', err))\n  })\n  await connection.connect()\n  // TODO resolve only when it is connected\n  return connection\n}\n\nexport interface ServerOpts extends ConnectionOpts {\n  serverSecret?: Buffer\n}\n\n/**\n * STREAM Server that can listen on an account and handle multiple incoming [`Connection`s]{@link Connection}.\n * Note: the connections this refers to are over ILP, not over the Internet.\n *\n * The Server operator should give a unique address and secret (generated by calling\n * [`generateAddressAndSecret`]{@link generateAddressAndSecret}) to each client that it expects to connect.\n *\n * The Server will emit a `'connection'` event when the first packet is received for a specific Connection.\n */\nexport class Server extends EventEmitter {\n  protected serverSecret: Buffer\n  protected plugin: Plugin\n  protected sourceAccount: string\n  protected connections: { [key: string]: Connection }\n  protected debug: Debug.IDebugger\n  protected enablePadding?: boolean\n  protected connected: boolean\n  protected connectionOpts: ConnectionOpts\n\n  constructor (opts?: ServerOpts) {\n    super()\n    if (!opts) {\n      opts = {}\n    }\n    this.serverSecret = opts.serverSecret || randomBytes(32)\n    this.plugin = opts.plugin || getPluginFromEnvironment() as Plugin\n    this.debug = Debug('ilp-protocol-stream:Server')\n    this.connections = {}\n    this.connectionOpts = Object.assign({}, opts, {\n      serverSecret: undefined\n    }) as ConnectionOpts\n    this.connected = false\n  }\n\n  /**\n   * Event fired when a new [`Connection`]{@link Connection} is received\n   * @event connection\n   * @type {Connection}\n   */\n\n  /**\n   * Connect the plugin and start listening for incoming connections.\n   *\n   * When a new connection is accepted, the server will emit the \"connection\" event.\n   *\n   * @fires connection\n   */\n  async listen (): Promise<void> {\n    if (this.connected && this.plugin.isConnected()) {\n      return\n    }\n    this.plugin.registerDataHandler(this.handleData.bind(this))\n    await this.plugin.connect()\n    this.sourceAccount = (await ILDCP.fetch(this.plugin.sendData.bind(this.plugin))).clientAddress\n    this.connected = true\n  }\n\n  /**\n   * Resolves when the next connection is accepted.\n   *\n   * To handle subsequent connections, the user must call `acceptConnection` again.\n   * Alternatively, the user can listen on the `'connection'` event.\n   */\n  async acceptConnection (): Promise<Connection> {\n    await this.listen()\n    /* tslint:disable-next-line:no-unnecessary-type-assertion */\n    return new Promise((resolve, reject) => {\n      this.once('connection', resolve)\n    }) as Promise<Connection>\n  }\n\n  /**\n   * Generate an address and secret for a specific client to enable them to create a connection to the server.\n   *\n   * Two different clients SHOULD NOT be given the same address and secret.\n   *\n   * @param connectionTag Optional connection identifier that will be appended to the ILP address and can be used to identify incoming connections. Can only include characters that can go into an ILP Address\n   */\n  generateAddressAndSecret (connectionTag?: string): { destinationAccount: string, sharedSecret: Buffer } {\n    if (!this.connected) {\n      throw new Error('Server must be connected to generate address and secret')\n    }\n    let token = base64url(cryptoHelper.generateToken())\n    if (connectionTag) {\n      if (!CONNECTION_ID_REGEX.test(connectionTag)) {\n        throw new Error('connectionTag can only include ASCII characters a-z, A-Z, 0-9, \"_\", and \"-\"')\n      }\n      token = token + '~' + connectionTag\n    }\n    const sharedSecret = cryptoHelper.generateSharedSecretFromToken(this.serverSecret, Buffer.from(token, 'ascii'))\n    return {\n      // TODO should this be called serverAccount or serverAddress instead?\n      destinationAccount: `${this.sourceAccount}.${token}`,\n      sharedSecret\n    }\n  }\n\n  /**\n   * Parse incoming ILP Prepare packets and pass them to the correct connection\n   */\n  protected async handleData (data: Buffer): Promise<Buffer> {\n    try {\n      let prepare: IlpPacket.IlpPrepare\n      try {\n        prepare = IlpPacket.deserializeIlpPrepare(data)\n      } catch (err) {\n        this.debug(`got data that is not an ILP Prepare packet: ${data.toString('hex')}`)\n        return IlpPacket.serializeIlpReject({\n          code: 'F00',\n          message: `Expected an ILP Prepare packet (type 12), but got packet with type: ${data[0]}`,\n          data: Buffer.alloc(0),\n          triggeredBy: this.sourceAccount\n        })\n      }\n\n      const localAddressParts = prepare.destination.replace(this.sourceAccount + '.', '').split('.')\n      if (localAddressParts.length === 0 || !localAddressParts[0]) {\n        this.debug(`destination in ILP Prepare packet does not have a Connection ID: ${prepare.destination}`)\n        throw new IlpPacket.Errors.UnreachableError('')\n      }\n      const connectionId = localAddressParts[0]\n\n      if (!this.connections[connectionId]) {\n        let sharedSecret\n        try {\n          const token = Buffer.from(connectionId, 'ascii')\n          sharedSecret = cryptoHelper.generateSharedSecretFromToken(this.serverSecret, token)\n          cryptoHelper.decrypt(sharedSecret, prepare.data)\n        } catch (err) {\n          this.debug(`got prepare for an address and token that we did not generate: ${prepare.destination}`)\n          throw new IlpPacket.Errors.UnreachableError('')\n        }\n\n        // If we get here, that means it was a token + sharedSecret we created\n        const connectionTag = (connectionId.indexOf('~') !== -1 ? connectionId.slice(connectionId.indexOf('~') + 1) : undefined)\n        const connection = new Connection({\n          ...this.connectionOpts,\n          sourceAccount: this.sourceAccount,\n          sharedSecret,\n          isServer: true,\n          connectionTag,\n          plugin: this.plugin\n        })\n        this.connections[connectionId] = connection\n        this.debug(`got incoming packet for new connection: ${connectionId}${(connectionTag ? ' (connectionTag: ' + connectionTag + ')' : '')}`)\n        try {\n          this.emit('connection', connection)\n        } catch (err) {\n          this.debug('error in connection event handler:', err)\n        }\n\n        // Wait for the next tick of the event loop before handling the prepare\n        await new Promise((resolve, reject) => setImmediate(resolve))\n      }\n\n      const fulfill = await this.connections[connectionId].handlePrepare(prepare)\n      return IlpPacket.serializeIlpFulfill(fulfill)\n\n    } catch (err) {\n      if (!err.ilpErrorCode) {\n        this.debug('error handling prepare:', err)\n      }\n      // TODO should the default be F00 or T00?\n      return IlpPacket.serializeIlpReject({\n        code: err.ilpErrorCode || 'F00',\n        message: err.ilpErrorMessage || '',\n        data: err.ilpErrorData || Buffer.alloc(0),\n        triggeredBy: this.sourceAccount || ''\n      })\n    }\n  }\n}\n\n/**\n * Creates a [`Server`]{@link Server} and resolves when the server is connected and listening\n */\nexport async function createServer (opts: ServerOpts): Promise<Server> {\n  const server = new Server(opts)\n  await server.listen()\n  return server\n}\n\nfunction base64url (buffer: Buffer) {\n  return buffer.toString('base64')\n    .replace(/=+$/, '')\n    .replace(/\\+/g, '-')\n    .replace(/\\//g, '_')\n}\n"]}